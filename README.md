### 1、java基础

#### 操作字符串的三大类

##### string

不可变的字符序列，每次都会生成新的String对象，而stringbuffer和stringbuilder则是在原有对象的基础上进行操作

##### Stringbuffer

可变长的字符序列，线程安全，但效率低，多线程环境下使用

#####  Stringbuilder

可变长的字符序列，线程不安全，但效率高，单线程环境下使用

#### final关键字的作用

##### 修饰类

便是该类不可以被继承

##### 修饰方法

表示该方法不能被重写

##### 修饰变量

表示该值是常量，不能被更改

#### equals与“==”的区别

==比较的如果是基本类型，则会比较值是否相等，如果比较的是基本类型，则比较的是引用是否相同

equals的本质也是==，String重写了Object中的equals方法，改成了值的比较

##### hascode值相等，则equals一定为true吗

不一定，同一个hascode值可能会有多个键值对，再散列表中存入数据的时候，就有过遇到相同hascode值相等即hash值相等，例如链表法（把值相同的元素用一个链表来表示）

##### String str="i"与 String str=new String("i")一样吗？

不一样，因为内存的分配方式不一样。String str="i"的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。

##### 普通类和抽象类的区别

普通类中不能有用抽象方法，抽象类中可以拥有普通方法

抽象类不能实例化，必须通过继承的形式重写其抽象方法，不能被final修饰，final修饰的类无法被继承，定义抽象类就是要让其他类继承的，会报错。

##### 接口和抽象类的区别

接口和抽象类定义完成后，抽象类使用extends关键字来继承，接口使用implements来实现

抽象类中可以有有构造函数，接口中不可以有

类可以实现多个接口，但只能继承一个类

接口中的方法默认使用public修饰，抽象类中方法可以任意使用修饰符

补充：如果继承抽象类或实现接口的类时普通类则必须实现所有的抽象方法，如果该类为抽象类则不必须

补充2：接口和抽象类的应用场景

抽象类：作为类，本质是一类对象的抽象，他的所有的子类必须拥有与他相同的特性

接口：更多的是关注行为本身，比如一个Tiger老虎类会捕食，但可能有些植物也会捕食，但他就不能继承Animal类

#### 重写和重载的区别

重载是指函数的方法名相同，但参数列表不同，重写必须有继承关系才能进行，是指子类实现父类的同名方法

#### 反射

指可以动态获取类的信息以及动态调用对象的方法的功能，在Java运行时环境中，对任意一个类，可以知道类有哪些属性和方法。

#### 注解

也叫元数据，是代码级的注释。程序可以通过反射来获取指定程序中元素的注解对象，然后通过该对象来获取注解中的元数据信息。

java5.0中定义了4中标准的元注解

①target，修饰的对象范围

②Retention，定义被保留的时间长短

③Documented，用于指定被该注解将被javadoc工具提取文档。

④Inherited，标记注解，表示这个标注的类型是可以被继承的

#### 异常

##### throw与throws

throw是真实的抛出一个异常

throws是声明，可能会抛出一个异常

##### final,finally与finalize

final是修饰符，修饰类时表示该类无法被继承，修饰方法时，表示方法无法被重写，修饰变量时，表示该变量无法被更改

finally用于异常处理语句结构try catch finally，表示总是执行

finalize，是Object类的一个方法，只有被垃圾回收器回收时才会调用此对象的finalize()方法

### 2、多线程

#### 线程和进程的区别

进程是系统进行资源分配和调度的最小单位，拥有独立的地址空间，进程之间的切换开销较大

线程是cpu调度和分配的最小单位，线程之间的切换开销较小。

#### 创建线程的几种方式

##### 继承Thread类重写run方法

##### 实现Runnable接口

##### 实现Callable接口

相比runnable接口，callable有返回值

##### 通过线程池创建

#### 创建线程池的几种方式

**newCachedThreadPool**

可缓存的线程池，线程池的规模不存在限制，自动回收空闲线程，自动添加新线程

**newFixedThreadPool**

固定长度的线程池，每提交一次任务，就创建一个线程，直到超过线程池的最大数量，超出的线程将在队列内等待

**newScheduledThreadPool**

固定长度的线程池，而且以延迟或定时的方式来执行任务

**newSingleThreadExecutor**

单线程的线程池，保证所有的线程按指定顺序执行

#### 线程池的核心参数

**corePoolSize**:核心线程数，是线程池在空闲的情况下任然会保留的线程数量。

**maximumPoolSize**：最大线程数，线程池允许创建的最大线程数。

**keepAliveTime**：线程空闲保持时间

unit：时间单位

**workQueue**：等待队列，用于存储等待执行任务的队列

- ArrayBlockingQueue：数组实现的有限队列，可以指定队列长度。
- LinkedBlockingQueue：基于链表的无限队列，长度可以无限扩展。
- PriorityBlockingQueue：优先级队列，可以设定队列里任务的优先级。

threadFactory：线程工厂，用于创建新线程的工厂。可以通过自定义线程工厂来定制线程的属性。

**handler**：拒绝策略，当线程池和队列都满了，无法处理新任务时的处理策略

- AbortPolicy（默认）：直接抛出 RejectedExecutionException 异常。
- DiscardPolicy：丢弃无法处理的任务。
- DiscardOldestPolicy：丢弃队列中最旧的任务，然后尝试重新提交任务。
- CallerRunsPolicy：由提交任务的线程处理该任务。

#### ThreadLocal

ThreadLocal是一个线程局部变量工具类，作用是可以多线程的环境下，为每个线程创建独立的变量副本，在多线程环境下，如果多个线程访问同一个变量，会导致线程安全等问题，ThreadLocal可以确保线程间数据隔离。多用于数据库连接管理和session管理。

ThreadLocal是通过其底层数据结构ThreadLocalMap完成的，ThreadLocalMap是一个自定义的哈希表，以ThreadLocal作为键，对应变量的值作为值。ThreadLocalMap存储在Thread中，每个Thread对象都包含一个ThreadLocalMap对象，互不干扰从而确保线程安全

#### TransmittableThreadLocal



#### sleep() 和 wait() 的区别

sleep来自Thread，wait来自Object，sleep不释放锁，wait释放锁，sleep时间到自动恢复，wait使用notify()或notifyAll()唤醒

####  线程池中 submit() 和 execute() 方法有什么区别

execute只能执行runnable类型的任务，submit既可以执行Runnable又可以执行Callable类型的任务

#### java中的锁

从需不需要锁住同步资源可分为，**乐观锁**与**悲观锁**，当锁同步资源失败后需不需要阻塞可区分**自旋锁**，从多个线程竞争的流程细节可分为**无锁**，**偏向锁**，**轻量级锁**和**重量级锁**，从线程竞争的公平性来说可分为**公平锁**与**非公平锁**，根据多个线程能否共享一把锁可分为**独占锁**和**共享锁**，根据锁是否可重入可分为**可重入锁**和**不可重入锁**

##### 乐观锁与悲观锁

悲观锁总是认为最坏的情况出现，写多读少，每次读写操作都会加上锁，Syncronized和ReentrantLock都是悲观锁。

乐观锁认为资源和数据不会被别人修改，所以读取时不会上锁，但在写操作时会判断数据是否被修改过，具体有两种实现机制——**版本号机制**和**CAS实现**。

**版本号机制**是在数据表中加一个version字段，每次修改数据都会使version+1，在线程提交更新时必须保证读取到version值与当前version值一致才更新成功，否则重新读取版本号和操作直至成功。

**CAS**是一种无锁算法，CAS中涉及三个要素，需要读写的内存值V，进行比较的值A，拟写入的新值B。当期望值A与内存值B相同时，将内存值V修改为B，否则什么都不做

##### 自旋锁

自旋锁是指当某个线程获取的锁被别人占用时，不会进入阻塞态，会等待一段时间然后继续尝试获取，其优点是如果该锁能在短时间内获取，则避免了操作系统进行的线程调度与线程切换，但如果长期得不到锁，会导致cpu长时间处于空闲状态，严重的损耗性能，阻止了其他线程的运行和调度

##### **无锁**，**偏向锁**，**轻量级锁**和**重量级锁**

无锁，就是不对资源进行上锁，所有的线程都可以对资源进行访问，但是只有一个线程能够成功修改资源，CAS的原理和应用就是无锁的实现

偏向锁，有时候锁会被同一个线程多次获取，偏向锁就是在这种情况下出现的，偏向锁会记录第一次获取他的线程id，等到下次线程进入和同步代码块时，就不在需要进行CAS操作来加锁和解锁，只需要判断线程id是否一致

轻量级锁，指当前锁为偏向锁时，资源被另外的线程访问，那么偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞。具体步骤为，当CAS操作替换线程ID失败后（存在多个线程竞争），会执行锁的撤销操作，等待原持有偏向锁的线程到达全局安全点后，暂停原持有偏向锁的线程，检测原持有偏向锁的状态，若退出同步，则唤醒原持有偏向锁的线程，进行下一步，否则升级为轻量级锁

重量级锁，尝试竞争轻量级锁的线程如果在多次自旋达到上限后，任然没有获取到锁，就会升级为重量级锁，将该线程阻塞，等待唤醒。重量级锁是通过内部对象的监视器锁实现的，而监视器锁的本质又是依赖与操作系统中的互斥锁（Mutex Lock）来实现的，需要操作系统从用户态切换到核心态，导致系统开销很大。

##### 公平锁与非公平锁

公平锁是指，竞争锁的线程按照FIFO，先来先得的顺序获取锁，而非公平锁指先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，也就是不公平的

##### 可重入锁与不可重入锁

可重入锁是指同一线程中当外层的函数获得锁之后，内层函数会自动获取该锁，不会因为外层函数的锁没有释放锁而阻塞，不可重入锁则相反。Syncronized和ReentrantLock都是可重入锁。

##### 独占锁与共享锁

独占锁是指，锁在同一时间内只能被一个线程所拥有，其他线程想要访问资源会被阻塞，共享锁是指，锁能够被多个线程所拥有，当某个线程对资源加上共享锁后，则其他线程只能对该资源再加共享锁，不能加独占锁，获取共享锁的线程只能读不能写数据。例如ReadWriteLock（读写锁），读锁是共享锁，写锁是独占锁

##### Syncronized与ReentrantLock的区别

Syncronized是jvm层面的锁，通过一个minitor对象来实现，而ReentrantLock依赖于AQS，是jdk实现的api层面的锁。AQS是一个多线程访问资源的同步器框架，包括一 个int类型的state变量，和一个由双向链表实现的队列，将等待锁的线程进入队列顺序等待

Syncronized不需要手动释放锁，ReentrantLock需要使用unlock手动释放锁

Syncronized锁不可以对等待锁的线程响应中断，ReentrantLock可以通过trylock设置超时方法，或调用interrupt响应中断

Syncronized是非公平锁，ReentrantLock可以手动调整为公平锁与非公平锁

ReentrantLock 只适用于代码块锁，而 synchronized 可用于实例方法、静态方法、代码块等

最核心的区别在于Syncronized适用于并发竞争少的情况，而ReentrantLock适用于并发竞争多的情况，因为Syncronized一旦升级为重量级锁，正常情况下无法降级，那么每次都会使操作系统从用户态切换到核心态，效率很低，而 ReentrantLock 是通过阻塞来提高性能的。

### 3、java集合

#### 数组和list之间的相互转换

##### list转数组

直接调用ArrayList中的toArray方法

##### 数组转list

使用Arrays.asList方法，数组如果是原始数据类型，需要转为封装类

##### List

排列有序，可重复的集合
	ArrayList：。。。
	LinkList：。。。

##### Set

排列无序，不可重复的集合
	Hashset：内部是hashMap，通过哈希值来存储，存储数据是先计算他的哈希值，如果两个元素的哈希值相同，会接着比较equals方法，结果为true，就视为同一元素，若为false，将哈希值相同的元素存在一列
	TreeSet：实际上是TreeMap实现的，底层用到的数据结构是红黑树。最大的特点就是一个有顺序的去重集合容器

##### Map

键值对，键不可重复，值可以重复
HashMap：数组+链表+红黑树，在java8中当链表中的元素超过了 8 个以后，会将链表转换为红黑树

HashTable：线程安全的hashmap，效率较低，但hashMap中可以接受为null的键和值。每个方法都是用sychronized。

ConcurrentHashMap：java8新加，线程安全的hashMap，使用的是可重入锁（ReentrantLock），将每个segment分别锁起来，每次写操作时只需要锁一个segment

TreeMap：可排序

### 4、JVM

#### jdk和jre的区别

jre指的是java运行环境，只需要安装jre就可以运行已经编译好的java程序

jkd是指java开发工具包，包括了jre，此外还有编译工具javac，打包工具jar，基础类库等

#### jvm的主要组成部分及其作用

##### 类加载器子系统（Class Loader Subsystem）

java虚拟机将描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类

##### 运行时数据区（Runtime Data Area）

Java虚拟机在执行Java程序时，会把它管理的内存划分为若干不同的数据区域。这区域各有各的用途以及生命周期。

##### 执行引擎（Execution Engine）

负责将被jvm所识别字节码指令翻译或编译为对应平台上的本地机器指令

##### 本地库接口（Native interface）

使得java可以与其他语言进行交互

#### 仔细说说类加载器

类从被加载到虚拟机内存开始，直到被卸载出内存，整个生命周期包括了**加载**、**验证**、**准备**、**解析**、**初始化**、**使用**、**卸载**七个阶段，其中验证、准备和解析统称为**连接**

在**加载**过程中，虚拟机会完成三件事

- 通过一个类的全限定名加载该类对应的二进制字节流
- 将字节流所代表的静态存储结构，转化为方法区的运行时数据结构
- 在内存中生成一个代表该类的java.lang.class对象，..作为方法区各个类访问该类的入口

**验证**主要是为了保证class文件的字节流信息符合虚拟机的要求，并且不会危害虚拟机自身的安全包括

文件格式验证，元数据验证，字节码验证，符号引用验证等

**准备**阶段，为类变量（static修饰的变量）分配内存空间，并设为默认值

**解析**阶段将常量池中的符号引用替换为直接引用

**初始化**阶段会将之前赋的默认值替换成真正的初始值，也就是编译器会将类文件声明的静态赋值变量和静态代码块合并生成类构造器<clinit>方法并调用

类加载器包括**启动类加载器**、**扩展类加载器**、**应用程序类加载器**和**自定义类加载器**

**启动类加载器**：由C/C++语言编写，嵌在jvm内部，负责加载java的核心库（JAVA_HOME\lib目录下的类或者被参数-Xbootclasspath指定的能够被虚拟机识别的类）

**扩展类加载器**：由JAVA语言编写，派生于ClassLoader类，负责加载JAVA_HOME\lib\ext或被java.ext.dirs系统变量指定的路径中的所有类库，开发者能直接使用这个类库

**应用程序类加载器**：由java语言编写，派生于ClassLoader类，负责加载环境变量classpath指定路径下的类库或系统属性java.class.path指定路径下的类库，正常情况下，应用程序中如果没有自定义类加载器，一般都是用的应用程序类加载器

**自定义类加载器**：除了以上三种类加载器，开发者还可以通过继承ClassLoader来自定义类加载器，定制类的加载方式

java虚拟机对Class文件采用的是按需加载的方式，也就是说只有需要使用到该类时，才会将他的class文件记载到内存，当触发类加载时，jvm并不知道由哪个类加载器去加载，都是默认先给应用程序类加载器，具体怎么分配，java默认使用的是**双亲委派模型**的类加载机制

**双亲委派模型**的工作过程是：如果一个类加载器接到了类加载的请求，他首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，每一层的加载器都是如此，所有的加载请求最终都会被传送到最顶层的启动类加载器中，只有父类加载器反馈自己无法完成这个加载请求时，子类加载器才会自己去尝试自己去完成加载。这样做的好处就是java类会随着他的类加载器具备了带有优先级的层级关系，例如Object类，每次加载时都会委派到最顶层的启动类加载器去加载，否则的话如果用户自己也编写了一个Object类，并放在程序的ClassPath中，那么系统中会出现多个不同的Object类。

#### 仔细说说java运行时数据区

java虚拟机会将所管理的内存分为**程序计数器**，**堆**，**方法区**，**java虚拟机栈**和**本地方法栈**，其中方法区和堆是线程共享的区域，程序计数器，虚拟机栈和本地方法栈为线程私有。

**方法区**：在JDK7之前叫永久代，在JDK8之后，改为了在本地内存中开辟了一块元空间，减少了内存溢出（OutOfMemory）的出现次数。线程共享区域，在虚拟机启动时创建，主要存储类型信息，方法信息，域信息，JIT代码缓存（即时编译后的代码）运行时常量池等，当方法区无法满足内存分配需求就会抛出OutOfMemory的错误。

**堆**：jvm所管理内存中最大的一块空间，线程共享区域，也是在虚拟机启动时创建，大小可以通过调整参数实现扩展。几乎所有的实例化都会在这里分配内存，是垃圾收集器管理的内存区域，在物理上可以不是连续的，在逻辑上是连续的，java堆中如果没有足够的内存满足分配需求，并且也无法扩展，就会抛出内存溢出（OutOfMemory）错误，包括**新生代**，**老年代**，**静态变量**和**字符串常量池**，分代有利于提高内存回收的效率

新生代又可以继续分为Eden区（伊甸园区）和Form Survivor和To Survivor区，默认比例为8:1:1。新生代采用的是Minor gc机制，对象优先在Eden区分配空间，大对象直接进入老年代，一次Minor gc首先将Eden区和From Survivor的存活下来的对象复制到To Survivor区，然后使对象的年龄+1，年龄达到阈值（默认15）后移到老年代，然后清空Eden区和From Survivor区，最后将To Survivor中的对象移到From Survivor区。

老年代比较稳定，采用Major gc机制，并且只有在触发了Minor gc，新生代对象进入老年代导致内存不够时触发。Major gc采用标记清除法，先扫描一遍所有的对象，标记出存活的对象，然后回收没有标记的对象。

**java虚拟机栈**：每个线程在创建时都会创建一个虚拟机栈，内部保存的是一个个栈帧。方法的一次调用到执行的过程，对应着一个栈帧从入栈到出栈的过程，线程私有。

每个栈帧都存储了方法的局部变量表，操作数栈，动态链接和返回地址等信息，局部变量表用于存放方法参数和方法内部定义的局部变量，操作数栈对应方法的执行，并且存放当前正在操作的变量，动态链接保存的是指向该栈帧所属方法在运行时常量池地址的指针，返回地址存放的是方法在程序计数器中的值，也就是该方法的指令地址。

**程序计数器**：保存的是一个指针，指向的是下一句需要执行的指令，每个线程都有一个独立的程序计数器，在任意一个时刻，一个cpu内核只会执行一条线程中的指令，切换线程后就是通过程序计数器来判断需要执行的指令。是唯一一个不会出现内存溢出错误的区域。

**本地方法栈**:与虚拟机栈类似，只不过虚拟机栈为java方法服务，而本地方法栈为本地方法服务。

补充：

①class常量池、字符串常量池与运行时常量池：class常量池指class文件中的常量池，用于存放编译期生成的各种字面量和符号引用，而运行时常量池除了class常量池中的数据还保存有运行期间新的变量和翻译出来的直接引用。而字符串常量池只保存有字面量的信息。

②string s ="aa" 与new String(“aa”)的区别：String s 为符号引用，直接引用字符串常量池的字面量，而new String实例化了String类，会在堆中也创造一个aa。

#### 仔细说说执行引擎

执行引擎包括**解释器**、**JIT（即时）编译器**和**垃圾回收器**

**解释器**：jvm运行程序时，逐行对字节码进行翻译为本地机器指令。效率低下。

**JIT编译器**：对某段代码一次性整体编译为与本地机器平台相关的机器语言，并存入方法区中的JIT代码缓存中，jvm执行时会直接从缓存中获取。提高了执行效率。

最初的java只提供了解释器，但是执行效率低，后来加入了编译器，会将调用频率高的热点代码编译成本地机器码

**垃圾回收器**：

垃圾就是指内存中不再使用的对象，意味着没有指针指向的对象，垃圾回收需要先判断内存中不再使用的对象（GC判断策略）然后再释放这些对象所占用的内存（GC收集算法）

GC判断策略一般有两种——**引用计数法**和**可达性分析法**

引用计数法是指给对象添加一个计数器，每有一个地方引用该对象，计数器+1，当计数器为0时，表明该对象不再被引用，这个方法实现简单，效率高但无法检测出循环引用。

可达性分析法是目前主流的虚拟机采用的算法，指从所有的GC Root节点出发，寻找该节点所引用的节点，然后继续寻找已找到的节点所引用的节点，直到将所有的节点寻找完毕，剩下的节点被认为是没有引用到的节点，判断为可回收对象，但不会马上回收，会执行一次finalize()方法，可以让开发者对该对象进行自定义操作，下一次依旧判断为可回收对象是才会被回收。GC Root包括虚拟机栈和本地方法栈所引用的对象，方法区中类静态属性和常量所应用的对象等等

垃圾回收算法有**标记清除法**，**标记整理法**，**复制算法**，**分代收集算法**

标记清除法就是通过遍历GC Roots将所有可达的对象标记，然后将没有标记的对象回收，缺点是效率低而且会产生内存空间碎片。

标记整理法与标记清除法类似，但是不会对未标记的对象直接回收，而是将标记的对象向一端移动，然后直接清理掉端边线以外的对象，缺点是效率低

复制算法是指将内存分为两个大小相等的部分，每次只使用其中的一块，当其中一块使用完后，将存活的对象复制到另一块，然后一次性清理这一块内存，优点是优化了标记清除法中效率低和内存碎片化严重的问题，但缺点是浪费了一半的内存，而且如果对象存活率高，消耗的时间也不可忽视。

分代收集算法是指将内存进行分块，不同的块采用不同的策略，新生代主要采用复制算法，老年代以标记清除法和标记整理法为主。

#### java的四种引用类型

强引用：只要存在就不会被回收，内存不够直接抛出内存溢出错误

软引用：只有内存不足是，才会对其回收

弱引用：只要垃圾回收机制运行，直接回收

虚引用：主要用于在对象被回收时，收到通知

#### jvm有哪些垃圾收集器

Serial与Seria lOld收集器，最早最基本的收集器，Serial执行单线程的复制算法，在进行垃圾回收时会暂停其他用户线程，Serial Old执行单线程的标记整理法。

ParallelNew，Serial收集器的多线程版本，垃圾回收时同样需要暂停工作线程。采用多线程复制算法。

ParallelScavenge，运用于新生代的多线程复制算法，目的是达到一个可控的吞吐量（吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间））

ParallelOld，ParallelScavenge的老年代版本，采用多线程的标记整理算法。

**CMS垃圾收集器**：使用与老年代，采用多线程的标记清除法，分为四个阶段

①初始标记：仅标记GC Root能直接关联到的对象，需暂停工作线程

②并发标记：进行GC Root跟踪的过程，可与工作现场并发执行

③重新标记：修正并发标记阶段因用户线程继续运行而导致标记发生变动的那一部分对象的标记，需暂停工作现场

④并发清除：清楚GC Roots的不可达对象，可与用户线程并发执行

由于耗时最长的并发标记和并发清除阶段都可以与用户线程一起工作，所以总体上看是与用户线程并发执行的，缺点有三个，并发收集会占用cpu资源，无法处理并发清除阶段产生的新垃圾，会产生内存碎片。

**G1垃圾收集器**：对于新生代和老年代都适用，采用标记整理法，可以设置最大停顿时间。

避免了全区域的收集，将堆内存划分为大小固定的几个独立区域，包括逻辑上的新生代和老年代，同时在后台设置一个优先级列表，每次根据设定的最大停顿时间，优先回收垃圾最多的区域，确保收集器实现最高的回收效率。

### 5、Mysql

#### 三大范式

第一范式：表中所有的列都是不可分割的最小单元数据

第二范式：表中所有的非主键必须完全依赖于主键

第三范式：表中的列不存在对非主键的依赖 

#### Mysql 索引及优化问题

**索引**：索引是存储系统为了快速查找记录的一种数据结构，需要额外开辟空间和数据维护工作，索引可以加快检索速度，但是同时也会降低增删改的速度。

目前 Mysql 采用的数据结构是 B+ Tree 

B+ Tree 相比于二叉树红黑树，由于拥有更多的子节点，所以树的高度更低，相应的 IO 次数就更少，效率更高

B+ Tree 相比与 B Tree，由于只有叶子节点存储实际的数据，B+ Tree的内部节点可以容纳更多的索引信息，树的高度可能会更低、并且 B+ Tree 的叶子节点之前通过指针相连形成了一个有序链表，使得顺序访问时更加高效。

索引的创建原则：只有数据量较大，超过了10w行数据才会考虑建立索引，并且建立的字段应该是查询比较频繁的字段，一般是查询条件，排序字段，或者分组字段。并且尽量选择组合索引，但是需要严格控制索引的数量。

索引失效的情况：使用组合索引时违反了最左匹配原则，使用 LIKE 的模糊查询 % 在前面会导致索引失效，在索引字段上面进行了运算操作或者类型转换会导致失效，组合索引中使用了范围查询，右侧的索引条件会失效。

**SQL 优化分析**：查看 sql 语句，是否是多表查询、表数据量大引起的慢 sql，然后通过 Mysql 自带的 EXPLAIN 关键字，查看其返回的结果。通过 key 和 key_len 字段，查看是否命中了索引，通过 type 字段查看 sql 是否存在优化空间，是否存在全索引扫描或全盘扫描。通过 extra 判断是否存在回表的情况。

回表查询：在 Mysql 中数据与索引在一起，即 B+ Tree 的叶子节点保存了整行的信息，这种索引方式被称为**聚簇索引**，在一张表中聚簇索引必须且只能存在一个，一般多为主键。而其他索引建立的 B+ Tree 叶子节点一般只保存主键信息，不保存整行数据，这种索引叫做**非聚簇索引**（二级索引，辅助索引），而通过非聚簇索引查询到主键，然后通过主键使用聚簇索引查询信息的方式就叫回表查询。

**分页查询的优化**：使用 Limit 作为一般的分页查询时，会随着偏移量的增加，查询速度急剧增加，因为 Limit（10000,10）时会把前10010条数据全部加载出来，可以使用**覆盖索引**和子查询进行优化，覆盖索引是指，通过索引进行查询时可以一次性拿到需要的列。例如：select * from myTable Limit 10000,10，一由于没有查询条件不会走索引，可以通过覆盖索引拿到id，select id from myTable Limit 10000,10，然后通过子查询找到这些id对应的信息 SELECT * from myTable a,(SELECT id from myTable  LIMIT 10000,10) b WHERE a.id = b.id。

**SQL 优化原则**：

​	1、从表的结构设计上优化，选择合适的数值和字符串类型。

​	2、从 SQL 语句编写上优化，避免使用select *，用 Union all 代替 Union 因为 Union 会额外的进行一次过滤操作，尽量使用 inner join 而不使用 Left Join 或 Right Join，如果必须使用也要以小表作为驱动，避免在 where 子句中对字段操作造成索引失效等操作。

​	3、对于数据量大的表，适当建立合适的索引

​	4、采用读写分离的架构

​	5、对于超过500w行的数据考虑分库分表

**分库分表**，包括垂直分库分表和水平分库分表，垂直分库指的是，根据业务类型的不同拆分不同的库。垂直分表说的是根据字段的使用频率，进行分表，将使用频率低的字段单独拆出一个表。水平分库分表说的是将一个库或者表拆分出几个库或者表，保存不同的数据，通过一定的路由规则进行匹配。水平分库分表可以使用 mycat 等中间栈开发。

#### **Mysql 事务及相关问题**

事务是一组操作的合集，是不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，要么同事成功要么同时失败。

**事务的特性（ACID）**：

原子性（Atomicity）：事务是不可分割的最小单位，要么全部成功，要么全部失败。

一致性（Consistency）：事务完成时，数据应该和预设结果保持一致。

隔离性（Isolation）：事务的执行不受其他事务的干扰。

持久性（Durability）：事务一旦提交或者回滚，他对数据的改动是永久性的。

**并发事务带来的问题**：

脏读：一个事务读到另外一个事务还没有提交的数据

不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同

幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在

解决方式：给事务设置**隔离级别**：

READ UNCOMMITTED 未提交读：三个问题都没有解决

READ COMMITTED 读已提交：解决了脏读的问题，没有解决不可重复读和幻读的问题

REPEATABLE READ 可重复读：解决了脏读和不可重复读的问题，没有解决幻读的问题，Mysql 默认的级别

SERIALIZABLE 串行化：都解决了，但是效率很低，一般不用

**事务的特性是如何保证的？**

Mysql 中存在一个 **redo log** 日志，记录的是数据页的物理变化，服务宕机可以用来同步数据，保证了事务的持久性，有一个 **undo log** 日志，记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，例如当我们 insert 一条数据时，他就会生成一个 delete 的语句，如果回滚就执行此操作，undo log 保证了事务的原子性和一致性。

其中隔离性由锁和 **MVCC** 机制保证，MVCC 翻译过来就是多版本并发控制，就是维护一个数据的多个版本，使得读写操作没有冲突。具体来说就是每张表，还存在一些**隐藏字段**包括 trx_id (事务id，用于记录最近一次修改数据的事务id，自增的)，roll_point（回滚指针，指向上一个版本的事务版本记录），事务修改数据后通过 undo log 记录回滚日志，存储老版本数据，并凭借 roll_point 字段形成一个链表，最后通过 **ReadView** 来决定读取那个版本的数据，ReadView 内部定义了一些匹配规则，不同隔离级别下的快照读也不一样，在RC（读已提交）级别下，每次读取都会生成一个 ReadView，而在RR（可重复读）级别下，只会生成一次 ReadView，后续复用。

#### 存储引擎 MyISAM 与 InnoDB

1.存储方式：虽然都是采用的B+树，但InnoDB采用的是聚簇索引，依托主键建立，将索引值与数据全部存储到一个结构中，MyISAM采用的是非聚簇索引或者叫二级索引，是将行的主键值保存在叶子结点中，然后通过主键值查找数据。MyISAM的存储文件有三个.frm(描述表结构的文件)，.MYD（表的数据文件），.MYI（存储的索引文件）。InnoDB只有两个.frm(描述表结构的文件)和.ibd（存储索引和数据）MyISAM的存储文件支持压缩，InnoDB的存储空间要大一点。

2.对事务的支持：MyISAM不支持事务，强调的是性能，查询的速度更快。InnoDB支持事务

3.对锁的支持：MyISAM仅支持表级锁，InnoDB支持行级锁

4.对外键的支持：MyISAM不支持外键，InnoDB支持外键

### 6、Spring

#### 简述Spring技术

spring是一个开源的轻量级的框架，他提供了一个可扩展的开发模型，内部支持对多种开源框架的集成，使得开发者可以专注于业务逻辑的实现，不用过多的关注底层的技术细节，其核心是IOC控制反转和AOP面向切面。

#### 简述 IOC

IOC指控制反转，是一种软件设计思想，指把对象的创建和依赖关系的管理权交给IOC容器，从而实现对象之间的解耦合和松耦合，IOC思想基于IOC容器完成，Spring中提供了两种不同的IOC容器

①BeanFactory，是Spring框架的基础设施，面向Spring本身，不提供给开发人员使用

②ApplicationContext，面向的是Spring框架的开发者，是BeanFactory的扩展，提供了更多了功能和特性，大部分应用场景都可以直接使用

IOC中具体的一种实现方式是依赖注入，依赖注入是指将一个对象由依赖的其他对象的引用注入到该对象中,依赖注入的方式有构造函数注入，setter方法注入，接口注入等等。

#### 简述 AOP

aop指面向切面，是一种编程范式，在传统的面向对象编程中，通常将系统功能划分为多个模块或类，每个模块负责特定的功能，但是有些功能横跨多个模块（比如：日志，事务管理，权限认证等），这些被称为横切关注点，与核心业务逻辑存在耦合，AOP就是将横切关注点从核心业务逻辑中分离出来，并将其封装成切面，实现对业务逻辑的解耦和重用。

在 Spring 中一般使用环绕通知 @Around 配和 @Pointcut 使用。Spring 中的事务其本质就是通过 AOP 来实现的，对方法前后进行拦截，在执行方法之前开启事务，目标方法执行完后根据情况进行提交后者回滚。

其中AOP对目标对象有两种代理方式

①JDK动态代理，多用于目标类是接口

②Cglib代理

#### Bean

bean 是指spring中由容器管理的对象实例

##### bean 的生命周期

1.通过构造函数实例化对象

2.依赖注入设置对象属性

3.处理Aware接口   如果bean实现了BeanNameAware、BeanFactoryAware、ApplicationContextAware等接口，会回调相应的方法

4.Bean后置处理器的前置操作，BeanPostProcessor的postProcessInitialization方法，在初始化之前进行一些额外的自定义操作

5.调用bean的初始化方法

6.bean后置处理器的后置操作，BeanPostProcessor的postProcessAfterInitialization，在初始化之后进行，可以在这里进行一些代理增强。

7.使用

8.销毁

##### bean 的作用域

singleton ：单例模式，ioc容器中只会存在一个bean，每次获取时返回同一个实例，多线程下不安全，默认方式

prototype：原型模式，每次容器获取bean时都会创建一个新的实例

request：一次请求一个实例

session：一次session中只会有一个实例

global Session：一个用户在整个应用程序中的会话，只会有一个实例

##### bean 的自动装配

@Autowired，用于自动将相匹配的bean注入到需要依赖的地方，可以简化依赖注入的配置和管理。有如下几种装配方式

ByType，通过参数类型自动装配

ByName，通过参数名自动装配

构造函数，通过构造函数的参数类型自动装配

autoDetect，首先通过构造函数使用autowire装配，失败则通过byType装配

##### bean 的循环依赖

循环依赖是指，两个或以上的 bean 相互注入，最终形成闭环，比如 A 依赖 B，B 依赖 A。

循环依赖在 Spring 中是允许存在的，依据三级缓存解决了大部分的循环依赖。

一级缓存：单例池，缓存那些已经经历了完整生命周期的 bean 对象

二级缓存：缓存早期的 bean 对象，那些生命周期没有走完的

三级缓存：缓存的是 ObjectFactory 对象工厂，用于创建对象

当 A 和 B 循环依赖时流程如下：

实例化 A → A生成一个 ObjectFactory → 由于 A 依赖 B ，此时 B 不存在，所以实例化 B → 创建一个 B 的 ObjectFactory → 由于 B 需要注入 A，所以通过 A 的 ObjectFactory 创建一个 早期的 bean 对象存在二级缓存中 → A 注入给 B，B 创建成功，存入一级缓存 → 将 创建好的B 注入给 A → A 创建成功。

三级缓存模式并不能解决所有的循环依赖，如果在构造函数阶段进行循环依赖则无法避免，可以使用 @Lazy 进行懒加载，需要对象的时候在进行 bean 对象的创建。

#### Spring其他问题

##### **Spring中的单例 bean 是线程安全的嘛**？

在 Spring 中 bean 默认就是单例的，可以通过 @Scope 注解进行修改，默认是 singleton。在 Spring 中注入的 Bean 一般都是无法修改的无状态对象，所以没有线程安全的问题，如果在 bean 中定义了可以修改的成员变量，是需要考虑线程安全问题的，可以加锁或者通过注解为 Prototype 模式。

##### **Spring 中事务失效的情况**

（情况很多，结合项目说几条即可）

1、自己手动处理了异常但是没有抛出。需要抛出异常

2、抛出的异常是检查类异常，如（FilelNotFoundException），可以配置 @Transactional(rollbackFor = Exception.class)

3、非 public 方法会导致事务失效

#### SpringMVC 流程

SpringMVC指（Model-View-Controller）模型-视图-控制器的架构模式组织和处理web请求

其流程有

①将客户端请求提交到前置控制器 DispatcherServlet

②由 DispatcherServlet 提交给处理器映射器（HandlerMapping），找到具体的处理器，并生产处理器对象，然后返回给 DispatcherServlet 

③DispatcherServlet 调用控制器适配器（HandlerAdapter），适配器经过适配后调用具体的处理器

④控制器处理完成后返回逻辑视图名称（ModelAndView），由视图解析器（ViewResolver）解析出实际的视图对象。

⑤视图对象接收模型数据，并将数据渲染为最终的响应结果

⑥视图将渲染好的响应结果返回给前置控制器（DispatcherServlet）,再由前置控制器返回给客户端

#### SpringBoot 自动配置原理

SpringBoot 是一个服务于 spring 框架的框架，目的在于简化 Spring 应用程序的开发和部署，提供默认的配置和约定，使开发者专注于业务逻辑的实现，其核心思想是约定大于配置。

SpringBoot 可以自动配置 Spring 应用程序的各种组件和功能，简化依赖管理，内置常见的 Servlet 容器（tomcat等）与 Spring 生态系统紧密集成，可以无缝地使用 Spring 框架的各种功能和模块。

在 Spring Boot 的启动项目中会有 @SpringBootApplication 注解，该注解封装了三个注解，有@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan。其中EnableAutoConfiguration是实现自动化配置的核心注解，该注解通过 @import 注解导入对应的配置选择器，内部就是读取了该项目和该项目所引用的 jar 包下的 classpath路径下 META-INF/spring.factories文件中所配置类的全类名，在这些配置类中所定义的Bean会根据诸如 @ConditionalOnClass 之类的条件注解判断是否有对应的 class 文件来决定需要将其导入到 Spring 容器中

### 7、Mybatis

#### Mybatis 的执行流程

① 加载并解析配置文件（如 mybatis-config.xml）

② 创建 SqlSessionFactory，全局唯一，用于创建具体的 SqlSession

③ 创建 SqlSession，SqlSession 是应用程序和 Mybatis 之间的接口，不是真正的执行者

④ SqlSession 通过 Executor 执行器去执行 sql，Executor 是真正的 sql 执行者，还负责管理事务、缓存等

⑤ Executor 读取 MappedStatement 信息执行，MappedStatement 封装了具体的 sql 语句，还会将输入与输出信息进行类型转换等

#### Mybatis 缓存

Mybatis 分为一级和二级缓存，都是通过 perpetualCache 实现的，perpetualCache 本质也是一个 HashMap

一级缓存默认开启，作用域是 SqlSession，所以当 SqlSession 进行 flush 或者 close 之后，缓存就会清空。

二级缓存默认关闭，需要在配置文件和映射文件中开启，不依赖于 SqlSession，当某个作用域进行增删改操作后或者调用方法显示清空的情况下，缓存会被清理。

#### 延迟加载

延迟加载是指需要调用数据时才进行加载，没用到时则不进行加载，可以通过 lazyLoadingEnable = true 开启

延迟加载是通过 CGLIB 代理目标对象来实现的，调用目标方法时，会进入拦截器的 invoke 方法，如何目标为 null，则执行 sql 查询，然后通过 set 方法设置属性值。

### 8、Spring Cloud 及分布式理论

#### **注册中心**  eureka nacos 

##### **注册中心的作用**：

项目采用的是 eureka 作为注册中心，这也是 Spring Cloud 体系中的一个核心组件。主要有三个作用

**服务注册**：服务提供者需要把自己的信息注册到 eureka，由 eureka 来保存这些信息，比如服务名称、IP、端口等

**服务发现**：消费者向 eureka 拉取服务列表信息，如果服务提供者有集群，则消费者会通过负载均衡算法，选择其中一个发起调用

**服务监控**：服务提供者每隔 30s 向 eureka 发送心跳，如果 eureka 超过 90s 没有接收到心跳，则从 eureka 中剔除

##### **nacos 与 eureka 的区别**：

两者都可以提供服务注册和发现，nacos 可以在配置文件中开启非临时实例模式，在临时实例模式下，Nacos 和 eureka 一样采用心跳模式，Nacos 集群默认采用 AP 模式，在非临时实例下，采用主动检测模式，检测到不正常时也不会将其剔除，会将其进行标记，集群中存在非临时实例时采用 CP 模式。

此外相比于 eureka，Nacos 除了提供注册中心的作用外，还是配置中心

#### 负载均衡 Ribbon

微服务的负载均衡主要使用的是一个 Ribbon 组件，比如我们使用 feign 远程调用的时候，底层的负载均衡就是使用了 ribbon

##### Ribbon 的均衡策略

RoundRobinRule：简单轮询策略，简单轮询服务列表选择服务器

WeightedResponseTimeRule：按权重来选择额服务器，响应时间越长，权重越小

RandomRule：随机选择一个可用的服务器

ZoneAvoidanceRule：区域敏感策略，默认策略，使用 Zone 对服务器进行分类，以区域可用的服务器为基础进行服务器的选择，而后对 Zone 内的多个服务器进行轮询

**自定义负载均衡策略如何实现**

1、创建类实现 IRule 接口，可以全局的指定策略。

2、在客户端的配置文件中，可以配置某一个服务的负载均衡策略

#### 服务熔断 Hystrix

在微服务中，一个服务的失败可能会导致整条链路上的服务都失效的情况，这种情况被称为服务雪崩。

一个服务的接口调用失败时，为了确保不收请求突增影响而变得不可用，确保服务崩溃，会使用**服务降级**。服务降级一般与 feign 接口整合，编写降级逻辑。

**服务熔断**：默认是关闭的，需要手动开启，在引导类上添加注解：@EnableCircuitBreaker

如果检测到 10s 内请求失败率超过 50%，就会触发熔断机制，之后每隔 5s 重新尝试请求微服务，如果微服务不能相应，继续走熔断机制，如果可达，则关闭熔断机制，恢复正常请求。

#### 微服务限流方式

**Nginx 限流**  控制速率（漏桶算法）：Nginx 可以存储一定数量的请求，多余的请求会被要求等待或抛弃，然后以恒定的速度每秒放出请求给网关，也可以控制并发数，限制单个 ip 的连接数和并发连接的总数。

**网关限流**：（令牌桶算法）使用 SpringCloud gateway 中支持的局部过滤器 RequestRateLimiter 做限流，每秒以固定的速度生成令牌，直到最大值，只有获得令牌的请求可以被通过。

#### CAP 及 BASE 理论

C（Consistency 一致性）、A （Availability 可用性）、P（Partition tolerance 分区容错性），由于微服务之间通过网络连接，所以一定会出现分区问题，出现分区时一致性和可用性就无法同时满足。

BASE 理论是对 CAP 的一种解决思路，包含三个思路：

**B**asically  **A**vailable (基本可用)：分布式系统出现故障时，允许损失部分可用性，保证核心可用。

**S**oft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。

**E**ventually Consistent（最终一致性）：虽然无法强一致性，但是在软状态结束后，最终达到数据一致。

解决分布式事务的思想和模型

最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP 思想）

强一致思想：各分支事务执行完业务先不要提交，等待彼此结果，而后统一提交或者回滚（CP 思想）

#### 分布式事务的解决方案

目前主流的方案主要有阿里的 Seata 框架和 MQ

seata 的 XA 模式：使用的是 CP 理念，等待各个分支事务提交，可以保证强一致性，性能差

seata 的 AT 模式：使用的是 AP 理念，底层通过 undolog 来实现的，性能好

seata 的 TCC 模式：使用的是 AP 理念，性能较好，但需要人工编码

MQ 模式：在 A 服务写数据的时候，需要在同一个事务内发送消息到另一个事务，异步，性能好。AP理念

### 9、Redis

redis是一个用C语言开发的高速缓存数据库，其作用是将数据库的热点数据缓存到内存中，避免进行多次的IO磁盘操作，提高系统效率。支持的数据结构有：String，list，set，zset，hash等。

#### Redis持久化

**RDB**：是指将当前内存中的数据集快照写入磁盘

​	缺点：可能会存在数据丢失的情况、且会占用cpu和内存消耗

**AOF**：是通过保存所有的Redis服务器执行的写命令来记录数据库状态

​	缺点：由于保存的时命令记录、所以会存在对一个key多次操作的情况，所以文件大小通常比RDB文件大得多。可以让AOF文件执行重写功能、也可以在配置文件中设置达到阈值时自动触发重写

在Redis4.0以后新增了 RDB 和 AOF 的混合持久化

Redis也会导致一些问题，诸如：缓存与数据库数据不一致，缓存穿透，缓存失效，缓存雪崩等

缓存与数据库数据一致性问题，可以通过设置缓存过期时间，或者分布式读写锁来解决。

**缓存穿透**：是指去查询一个不存在的数据，如果存储层中查不到数据通常不会写入缓存层，

​	解决方式：可以缓存空对象，但将对象的过期时间设置较小或者使用布隆过滤器解决。

**缓存击穿**：是指当Redis中一个热点在失效的同时大量的请求过来，全部到达数据库，压垮数据库，

​	解决方式：设置互斥锁：保证强一致性、但性能较差。

​					   设置逻辑过期：将过期时间存入缓存中、拿到数据时先查看他是否逻辑过期、若过期、则开启互斥锁开启新线程更新缓存中的值、本线程则返回过期数据。其他线程获取互斥锁失败则直接返回过期数据。保证高可用、性能较好。

**缓存雪崩**：是指Redis中缓存的数据大面积同时失效，或者Redis宕机，从而会导致大量请求直接到数据库，压垮数据库。

​	解决方式：可以通过设置合理有效期，给不同的KEY的过期时间添加一个（1-5分钟的）随机值、添加多级缓存等方式解决

#### Redis 数据删除策略

**惰性删除**：设置的该 KEY 的时间过期后、先不去管他、当需要该 KEY 的时候、再检测他是否过期，如果过期则删除、反之则返回其值。

​	优点：对 CPU 的占用较小，对于用不到的 KEY 不会浪费时间检查。

​	缺点：对内存的占用较大，对于很多用不到的 KEY 会一直存在内存中、不会被释放。

**定期删除**：每隔一段时间，对其中的一部分 KEY 进行检查、删除其中过期的 KEY (直到检查完所有的 KEY ) 定期删除有俩中模式:

​	SLOW 模式：是定时任务，执行评率默认为10hz，每次不超过25ms，可通过配置文件修改频率。

​	FAST 模式：执行评率不固定，但每次不低于2ms，每次耗时不超过1ms。

​	优点：可以通过限制删除操作的执行时长和频率减少对 CPU 的影响、定期删除也可以有效的释放被占用的内存。

​	缺点：难以确定删除操作执行的时长和频率。

**Redis 是两种策略配和一起使用的**

#### Redis 数据淘汰策略

与删除策略不同的是、删除策略指的是设置的 KEY 过期之后删除的问题、而淘汰策略指的是当 Redis 中的内存不够时、此时再向 Redis 中添加新的 KEY 那么Redis 就会按照某种规则将内存当中的数据删除。

**noeviction**：不淘汰任何 KEY，但内存满时不允许添加新的数据。这是默认的策略

**volatile-ttl**：对设置了 TTL 的 KEY，按照 TTL 的剩余值，TTL较小的优先被淘汰。

**volatile-random**：对于设置了 TTL 的 KEY 随机淘汰。

**volatile-lru**：对设置了 TTL 的 KEY，按照 LRU（最近最少使用）算法进行淘汰。

**volatile-lfu**：对设置了 TTL 的 KEY，按照 LFU （最少频率使用）算法进行淘汰。

**allkeys-random**：对于所有的 KEY 随机淘汰。

**allkeys-lru**：对于全体的 KEY，按照 LRU（最近最少使用）算法进行淘汰。

**allkeys-lfu**：对于全体的 KEY，按照 LFU （最少频率使用）算法进行淘汰。

#### 双写一致性问题

（先说业务背景：允许延迟一致性）

​	**一致性要求高**：使用 redission 提供的读写锁、

​	**允许延迟一致**：修改数据库的时候、通过MQ发送通知、删除缓存。

#### Redis实现分布式锁

**使用SETNX指令**：该指令只有在key不存在的时候才能将key的值设置为value，若key已经存在，则SETNX不会做任何动作。在资源使用完成后使用DEL删除该key即可以释放锁。此外还可以通过expire指令设置过期时间。

**使用SET扩展指令**：使用SETNX和expire不是原子操作的，所以如果执行了SETNX指令但是expire指令还没执行性，线程就挂掉了。就会导致死锁。Redis2.6.12之后，Redis扩展了SET命令的参数，只需要使用SET lock 1 EX 10 NX一条命令即可

但是使用SET扩展指令还是会存在两个问题：如果线程还没有执行完成就被自动过期了，锁就会被另一个线程锁获取，第一个线程执行完成后所释放的锁是其他线程的锁。

第一个问题可以使用redission，在线程获取锁时开启一个守护线程自动续期锁的过期时间。第二个问题可以通过新增一个判断条件，判断线程id是自己时才删除锁。

**Redission 实现的锁机制**：

在 Redisson 中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的业务还没有执行完成时，Redission 中引入了一个看门狗的机制，就是每隔一段时间，都会检查当前业务是否还持有锁，如果持有则续期锁的持续时间，当业务执行完成之后需要手动释放锁。

另外当多个线程的竞争锁的时候，获取锁失败时，会尝试自旋一段时间，这样可以第一时间获取锁。

且 Redission 实现的锁是可重入的，锁的信息在 Redis 中进行存储存的事 hash 结构的，数据记录了线程信息和重入的次数，索取锁的时候会判断线程 ID ，如果是当前线程才会开始计数。每次释放锁都会使重入次数减一，减到0的时候才会删除该 KEY。

**使用 redlock**：以上方法都是基于单机模式的Redis实现的，如果出现线程1从主库上获取锁，然后主库异常宕机，SET命令还未同步到从库上。之后从库提升为新的主库，锁在新的主库上丢失了，另一个线程也可以成功获取锁。不过redlock的性能太差，一般不建议使用，如果一定需要保持数据的一致性，可以采用zookeeper实现的分布式锁。

redlock大概原理如下：

使用redlock前，需要至少5个Redis实例，并且这些实例完全相互独立，不存在主从复制。

1.客户端现获取当前时间戳T1

2.客户端依次向这些Redis实例发送加锁请求，并且设置超时时间，如果一个实例获取锁失败就立即向下一个实例申请加锁。

3.如果客户端从大多数实例获取锁成功，并且再次获取当前时间戳T2，只有T2-T1<锁的过期时间才会加锁成功

4.如果获取成功，锁的有效时间等于原有效时间-获取锁的时间。如果获取锁失败，向全部节点发起释放锁请求。

#### Redis 集群模式

redis 提供的集群方案总共有三种：主从同步、哨兵模式、Redis 分片集群

**主从同步**：单节点的 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，可以搭建主从集群，实现读写分离，一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据后再把数据同步到从节点中。

​	主要流程：1.从节点请求同步数据、同时会给主节点发送自己的 replication id 和 offset 偏移量。

​						2.主节点根据从节点 replication id 与自己的 replication id 是否一致，若一致则说明该从节点不是第一次同步数据，触发增量同步，若不一致则说明该节点是第一次同步数据，选择全量同步。

​						3.若不一致，选择全量同步，则主节点会发送自己的 replication id 和 offset 偏移量是主从节点的信息保持一致。然后主节点执行 bgsave 生成 rdb 文件发送给从节点文件执行，从节点先清除自己的数据，然后执行此 rdb 文件。如果在 rdb 文件的生成执行期间，依然有请求到了主节点，则会以记录命令的形式保存到缓冲区（也就是一个日志文件）然后发送给从节点，这样就能保证主从节点完全一致。

​						4.若一致，选择增量同步，则主节点根据从节点的 offset 偏移量，从记录的命令日志中发送从节点 offset 值之后的数据，进是行同步。

**哨兵模式**：是指主从集群的自动故障恢复，包括检测、自动故障恢复和通知。哨兵会定时监测主从节点是否正常工作，若主节点宕机，则哨兵会选择一个从节点作为主节点，故障回复后也会以新的主节点为主，最后把主节点通知给客户端。

​		redis 集群的脑裂：这个情况很少见，说的是由于 redis 的主从节点与哨兵节点分别处于不同的网络分区，使得哨兵无法感知到主节点，认为主节点发生了故障，从而将一个从节点提升为主节点。于是同时存在了两个主节点，这样会导致客户端写入数据时还发生在老的主节点，而网络恢复后哨兵会将老主节点降为从节点，会导致数据丢失。

​		解决方式：可以在 redis 的配置中设置最少的从节点数量以及主从数据复制与同步的延迟时间，达不到要求则拒绝请求。

**分片集群**：分片集群解决的事海量数据的存储问题，集群中存在多个主节点，每个主节点存储不同的数据，并且可以给每个主节点增加多个从节点以此保证高并发能力，每个主节点之间通过ping监测彼此的运行状态，客户端的请求可以访问集群中的任意节点，最终都会被转发到正确的节点。

​		分片集群引入了 hash 槽的概念，一共有16384个哈希槽，每个主节点绑定一定范围的哈希槽，key 通过 CRC16 校验后对16384取模来决定放入那个槽，通过这个槽找到对应的节点进行存储和取值。

### 10、RabbitMQ

RabbitMQ是基于AMQP协议实现的消息中间件。消息中间件可以用于①异步处理，提升响应速度②流量削峰，解决高并发问题③系统解耦，提升系统可用性。

包括生产者（producer），消费者（consumer），交换机（Exchange），队列（Queue）

#### **工作流程**

客户端和RabbitMQ服务器建立tcp连接，并建立信道（Channel）

生产者声明交换机和队列并设置相关属性（比如是否持久化，交换机类型等）。

生产者通过绑定键（Binding Key）将队列和交换机绑定起来。

生产者发送消息到交换机

交换机通过路由键（Routing Key）将消息发送给相应的队列

消费者请求消费信息，并可能注册一个回调函数

消费者从队列中接受消息，并发送ACK确认收到消息

队列将该消息删除

#### 交换机类型

直连交换机（direct Exchange）：通过路由键，将消息发送到与之匹配的队列上

主题交换机（topic Exchange）：可以通过路由键和设置通配符（#（代表零个或多个字符）或*（代表一个字符））进行匹配，将消息发送到一个或多个相匹配的队列上

扇形交换机（Fanout Exchange）：无视路由键，将消息发送到所有与其绑定的队列上

延迟交换机（Delay Exchange）：能延迟发送到队列

死信交换机：可以接受被拒绝的消息，超过最大生存时间的消息，队列达到最大长度后的消息。

#### RabbitMQ保证消息不被重复消费

1.设置消息全局ID，或者写一个唯一标识

2.利用Redis的SETNX指令，

#### RabbitMQ保证消息不会丢失（高可用）

消息丢失的情况有三种，

①在生产者传入RabbitMQ的过程中丢失。

②RabbitMQ接收到消息后，还未被消费就异常宕机。

③消费者接收到消息后还未被消费就挂掉了。

针对①：

​	1.开启RabbitMQ的事务：当RabbitMQ没有接收到消息时回滚事务，只有接收到了才提交事务。事务机制是同步的会降低吞吐量

​	2.将信道设置为confirm模式，如果RabbitMQ接收到消息会发送一个ack，表示已接收

针对②：

​	1.消息持久化：将消息持久化需要分别将交换机设置持久化，队列持久化和消息持久化发送（delivery Mode=2）

​	2.设置镜像集群模式：镜像集群模式下，创建的queue无论是元数据还是消息数据，都存在多个实例，一个实例挂了还可以从另一个实例恢复。（普通集群模式下，其他实例只保存一个queue的元数据不保存消息数据，其他实例可以返回包含消息数据的实例。这个模式只能提高RabbitMQ的吞吐量）

针对③：

​	修改自动确认机制，改为手动确认

### 11、kafka

### 12、架构
