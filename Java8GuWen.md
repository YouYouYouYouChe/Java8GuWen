### 1、java基础



#### 操作字符串的三大类

**string**

不可变的字符序列，每次都会生成新的String对象，而stringbuffer和stringbuilder则是在原有对象的基础上进行操作

string的长度：由于 string 的底层是通过 char[] 数组来实现的，而且由于数组下标使用的是 int 类型，所以 string 类型的理论最大长度为 Integer.MAX_VALUE(2^{31}-1)，约 21 亿字符。但实际上还受到 JVM 内存大小的影响。

**Stringbuffer**

可变长的字符序列，线程安全，但效率低，多线程环境下使用

**Stringbuilder**

可变长的字符序列，线程不安全，但效率高，单线程环境下使用



#### final关键字的作用

**修饰类**

便是该类不可以被继承

**修饰方法**

表示该方法不能被重写

**修饰变量**

表示该值是常量，不能被更改



#### equals与“==”的区别

==比较的如果是基本类型，则会比较值是否相等，如果比较的是基本类型，则比较的是引用是否相同

equals的本质也是==，String重写了Object中的equals方法，改成了值的比较



#### hascode值相等，则equals一定为true吗

不一定，同一个hascode值可能会有多个键值对，再散列表中存入数据的时候，就有过遇到相同hascode值相等即hash值相等，例如链表法（把值相同的元素用一个链表来表示）



#### String str="i"与 String str=new String("i")一样吗？

不一样，因为内存的分配方式不一样。String str="i"的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。



#### final,finally与finalize

final是修饰符，修饰类时表示该类无法被继承，修饰方法时，表示方法无法被重写，修饰变量时，表示该变量无法被更改

finally用于异常处理语句结构try catch finally，表示总是执行

finalize，是Object类的一个方法，只有被垃圾回收器回收时才会调用此对象的finalize()方法



#### 普通类和抽象类的区别

普通类中不能有用抽象方法，抽象类中可以拥有普通方法

抽象类不能实例化，必须通过继承的形式重写其抽象方法，不能被final修饰，final修饰的类无法被继承，定义抽象类就是要让其他类继承的，会报错。



#### 接口和抽象类的区别

接口和抽象类定义完成后，抽象类使用extends关键字来继承，接口使用implements来实现

抽象类中可以有有构造函数，接口中不可以有

类可以实现多个接口，但只能继承一个类

接口中的方法默认使用public修饰，抽象类中方法可以任意使用修饰符

补充：如果继承抽象类或实现接口的类时普通类则必须实现所有的抽象方法，如果该类为抽象类则不必须

补充2：接口和抽象类的应用场景

抽象类：作为类，本质是一类对象的抽象，他的所有的子类必须拥有与他相同的特性

接口：更多的是关注行为本身，比如一个Tiger老虎类会捕食，但可能有些植物也会捕食，但他就不能继承Animal类



#### 重写和重载的区别

重载是指函数的方法名相同，但参数列表不同，重写必须有继承关系才能进行，是指子类实现父类的同名方法



#### 反射

指可以动态获取类的信息以及动态调用对象的方法的功能，在Java运行时环境中，对任意一个类，可以知道类有哪些属性和方法。



#### 注解

也叫元数据，是代码级的注释。程序可以通过反射来获取指定程序中元素的注解对象，然后通过该对象来获取注解中的元数据信息。

java5.0中定义了4中标准的元注解

①target，修饰的对象范围

②Retention，定义被保留的时间长短

③Documented，用于指定被该注解将被javadoc工具提取文档。

④Inherited，标记注解，表示这个标注的类型是可以被继承的



#### 异常

**throw与throws**

throw是真实的抛出一个异常

throws是声明，可能会抛出一个异常



### 2、多线程



#### 线程和进程的区别

进程是系统进行资源分配和调度的最小单位，拥有独立的地址空间，进程之间的切换开销较大

线程是cpu调度和分配的最小单位，线程之间的切换开销较小。



#### 创建线程的几种方式

- 继承Thread类重写run方法

- 实现Runnable接口，无返回值

- 实现Callable接口，有返回值

- 通过线程池创建

  

#### 创建线程池的几种方式

- 通过Executors快速创建

  - **newCachedThreadPool**：可缓存的线程池，线程池的规模不存在限制，自动回收空闲线程，自动添加新线程
  - **newFixedThreadPool**：固定长度的线程池，每提交一次任务，就创建一个线程，直到超过线程池的最大数量，超出的线程将在队列内等待
  - **newScheduledThreadPool**：固定长度的线程池，而且以延迟或定时的方式来执行任务
  - **newSingleThreadExecutor**：单线程的线程池，保证所有的线程按指定顺序执行

- 通过 ThreadPoolExecutor 自定义线程池参数手动创建

  

#### 线程池的核心参数

**corePoolSize**:核心线程数，是线程池在空闲的情况下任然会保留的线程数量。

**maximumPoolSize**：最大线程数，线程池允许创建的最大线程数。

**keepAliveTime**：线程空闲保持时间

unit：时间单位

**workQueue**：等待队列，用于存储等待执行任务的队列

- ArrayBlockingQueue：数组实现的有限队列，可以指定队列长度。
- LinkedBlockingQueue：基于链表的无限队列，长度可以无限扩展。
- PriorityBlockingQueue：优先级队列，可以设定队列里任务的优先级。

threadFactory：线程工厂，用于创建新线程的工厂。可以通过自定义线程工厂来定制线程的属性。

**handler**：拒绝策略，当线程池和队列都满了，无法处理新任务时的处理策略

- AbortPolicy（默认）：直接抛出 RejectedExecutionException 异常。

- DiscardPolicy：丢弃无法处理的任务。

- DiscardOldestPolicy：丢弃队列中最旧的任务，然后尝试重新提交任务。

- CallerRunsPolicy：由提交任务的线程处理该任务。

  

#### ThreadLocal

ThreadLocal是一个线程局部变量工具类，作用是可以多线程的环境下，为每个线程创建独立的变量副本，在多线程环境下，如果多个线程访问同一个变量，会导致线程安全等问题，ThreadLocal可以确保线程间数据隔离。多用于数据库连接管理和session管理。

ThreadLocal是通过其底层数据结构ThreadLocalMap完成的，ThreadLocalMap是一个自定义的哈希表，以ThreadLocal作为键，对应变量的值作为值。ThreadLocalMap存储在Thread中，每个Thread对象都包含一个ThreadLocalMap对象，互不干扰从而确保线程安全



#### TransmittableThreadLocal



#### sleep() 和 wait() 的区别

sleep来自Thread，wait来自Object，sleep不释放锁，wait释放锁，sleep时间到自动恢复，wait使用notify()或notifyAll()唤醒



####  线程池中 submit() 和 execute() 方法有什么区别

execute只能执行runnable类型的任务，submit既可以执行Runnable又可以执行Callable类型的任务



#### java中的锁

从需不需要锁住同步资源可分为，**乐观锁**与**悲观锁**，当锁同步资源失败后需不需要阻塞可区分**自旋锁**，从多个线程竞争的流程细节可分为**无锁**，**偏向锁**，**轻量级锁**和**重量级锁**，从线程竞争的公平性来说可分为**公平锁**与**非公平锁**，根据多个线程能否共享一把锁可分为**独占锁**和**共享锁**，根据锁是否可重入可分为**可重入锁**和**不可重入锁**

##### 乐观锁与悲观锁

悲观锁总是认为最坏的情况出现，写多读少，每次读写操作都会加上锁，Syncronized和ReentrantLock都是悲观锁。

乐观锁认为资源和数据不会被别人修改，所以读取时不会上锁，但在写操作时会判断数据是否被修改过，具体有两种实现机制——**版本号机制**和**CAS实现**。

**版本号机制**是在数据表中加一个version字段，每次修改数据都会使version+1，在线程提交更新时必须保证读取到version值与当前version值一致才更新成功，否则重新读取版本号和操作直至成功。

**CAS**是一种无锁算法，CAS中涉及三个要素，需要读写的内存值V，进行比较的值A，拟写入的新值B。当期望值A与内存值B相同时，将内存值V修改为B，否则什么都不做

##### 自旋锁

自旋锁是指当某个线程获取的锁被别人占用时，不会进入阻塞态，会等待一段时间然后继续尝试获取，其优点是如果该锁能在短时间内获取，则避免了操作系统进行的线程调度与线程切换，但如果长期得不到锁，会导致cpu长时间处于空闲状态，严重的损耗性能，阻止了其他线程的运行和调度

##### **无锁**，**偏向锁**，**轻量级锁**和**重量级锁**

无锁，就是不对资源进行上锁，所有的线程都可以对资源进行访问，但是只有一个线程能够成功修改资源，CAS的原理和应用就是无锁的实现

偏向锁，有时候锁会被同一个线程多次获取，偏向锁就是在这种情况下出现的，偏向锁会记录第一次获取他的线程id，等到下次线程进入和同步代码块时，就不在需要进行CAS操作来加锁和解锁，只需要判断线程id是否一致

轻量级锁，指当前锁为偏向锁时，资源被另外的线程访问，那么偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞。具体步骤为，当CAS操作替换线程ID失败后（存在多个线程竞争），会执行锁的撤销操作，等待原持有偏向锁的线程到达全局安全点后，暂停原持有偏向锁的线程，检测原持有偏向锁的状态，若退出同步，则唤醒原持有偏向锁的线程，进行下一步，否则升级为轻量级锁

重量级锁，尝试竞争轻量级锁的线程如果在多次自旋达到上限后，任然没有获取到锁，就会升级为重量级锁，将该线程阻塞，等待唤醒。重量级锁是通过内部对象的监视器锁实现的，而监视器锁的本质又是依赖与操作系统中的互斥锁（Mutex Lock）来实现的，需要操作系统从用户态切换到核心态，导致系统开销很大。

##### 公平锁与非公平锁

公平锁是指，竞争锁的线程按照FIFO，先来先得的顺序获取锁，而非公平锁指先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，也就是不公平的

##### 可重入锁与不可重入锁

可重入锁是指同一线程中当外层的函数获得锁之后，内层函数会自动获取该锁，不会因为外层函数的锁没有释放锁而阻塞，不可重入锁则相反。Syncronized和ReentrantLock都是可重入锁。

##### 独占锁与共享锁

独占锁是指，锁在同一时间内只能被一个线程所拥有，其他线程想要访问资源会被阻塞，共享锁是指，锁能够被多个线程所拥有，当某个线程对资源加上共享锁后，则其他线程只能对该资源再加共享锁，不能加独占锁，获取共享锁的线程只能读不能写数据。例如ReadWriteLock（读写锁），读锁是共享锁，写锁是独占锁

##### Syncronized与ReentrantLock的区别

Syncronized是jvm层面的锁，通过一个minitor对象来实现，而ReentrantLock依赖于AQS，是jdk实现的api层面的锁。AQS是一个多线程访问资源的同步器框架，包括一 个int类型的state变量，和一个由双向链表实现的队列，将等待锁的线程进入队列顺序等待

Syncronized不需要手动释放锁，ReentrantLock需要使用unlock手动释放锁

Syncronized锁不可以对等待锁的线程响应中断，ReentrantLock可以通过trylock设置超时方法，或调用interrupt响应中断

Syncronized是非公平锁，ReentrantLock可以手动调整为公平锁与非公平锁

ReentrantLock 只适用于代码块锁，而 synchronized 可用于实例方法、静态方法、代码块等

最核心的区别在于Syncronized适用于并发竞争少的情况，而ReentrantLock适用于并发竞争多的情况，因为Syncronized一旦升级为重量级锁，正常情况下无法降级，那么每次都会使操作系统从用户态切换到核心态，效率很低，而 ReentrantLock 是通过阻塞来提高性能的。



### 3、java集合



#### 数组和list之间的相互转换

**list转数组**

​	直接调用ArrayList中的toArray方法

**数组转list**

​	使用Arrays.asList方法，不可改变其中的元素，数组如果是原始数据类型，需要转为封装类

​	使用Lists.newArrayList



#### List

排列有序，可重复的集合
	**ArrayList**：。。。
	**LinkList**：。。。



#### Set

排列无序，不可重复的集合
	**Hashset**：内部是hashMap，通过哈希值来存储，存储数据是先计算他的哈希值，如果两个元素的哈希值相同，会接着比较equals方法，结果为true，就视为同一元素，若为false，将哈希值相同的元素存在一列
	**TreeSet**：实际上是TreeMap实现的，底层用到的数据结构是红黑树。最大的特点就是一个有顺序的去重集合容器



#### Map

键值对，键不可重复，值可以重复
**HashMap**：数组+链表+红黑树，在java8中当链表中的元素超过了 8 个以后，会将链表转换为红黑树

​    **扩容机制**：HashMap 初始容量大小为 16，默认加载因子为 0.75，当实际大小超过阈值（容量大小 * 加载因子）将会触发扩容，容量扩充为之前的两倍。因为 size 也受到 Integer 的长度限制，且每次扩容两倍，所以HashMap的理论最大容量为 2^30 ，但实际上也受到 JVM 内存大小限制。

**HashTable**：线程安全的hashmap，效率较低，但hashMap中可以接受为null的键和值。每个方法都是用sychronized。

**ConcurrentHashMap**：java8新加，线程安全的hashMap，使用的是可重入锁（ReentrantLock），将每个segment分别锁起来，每次写操作时只需要锁一个segment

**TreeMap**：可排序



### 4、JVM



#### jdk和jre的区别

jre指的是java运行环境，只需要安装jre就可以运行已经编译好的java程序

jkd是指java开发工具包，包括了jre，此外还有编译工具javac，打包工具jar，基础类库等



#### jvm的主要组成部分及其作用

- **类加载器子系统**（Class Loader Subsystem）：java虚拟机将描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类

- **运行时数据区**（Runtime Data Area）：Java虚拟机在执行Java程序时，会把它管理的内存划分为若干不同的数据区域。这区域各有各的用途以及生命周期。

- **执行引擎**（Execution Engine）：负责将被jvm所识别字节码指令翻译或编译为对应平台上的本地机器指令

- **本地库接口**（Native interface）：使得java可以与其他语言进行交互

  

#### 类加载机制

##### 类加载流程

类从被加载到虚拟机内存开始，直到被卸载出内存，整个生命周期包括了**加载**、**验证**、**准备**、**解析**、**初始化**、**使用**、**卸载**七个阶段，其中验证、准备和解析统称为**连接**

在**加载**过程中，虚拟机会完成三件事

- 通过一个类的全限定名加载该类对应的二进制字节流
- 将字节流所代表的静态存储结构，转化为方法区的运行时数据结构
- 在内存中生成一个代表该类的java.lang.class对象，..作为方法区各个类访问该类的入口

**验证**主要是为了保证class文件的字节流信息符合虚拟机的要求，并且不会危害虚拟机自身的安全包括

文件格式验证，元数据验证，字节码验证，符号引用验证等

**准备**阶段，为类变量（static修饰的变量）分配内存空间，并设为默认值

**解析**阶段将常量池中的符号引用替换为直接引用

**初始化**阶段会将之前赋的默认值替换成真正的初始值，也就是编译器会将类文件声明的静态赋值变量和静态代码块合并生成类构造器<clinit>方法并调用



##### 类加载器

类加载器包括**启动类加载器**、**扩展类加载器**、**应用程序类加载器**和**自定义类加载器**

**启动类加载器**：由C/C++语言编写，嵌在jvm内部，负责加载java的核心库（JAVA_HOME\lib目录下的类或者被参数-Xbootclasspath指定的能够被虚拟机识别的类）

**扩展类加载器**：由JAVA语言编写，派生于ClassLoader类，负责加载JAVA_HOME\lib\ext或被java.ext.dirs系统变量指定的路径中的所有类库，开发者能直接使用这个类库

**应用程序类加载器**：由java语言编写，派生于ClassLoader类，负责加载环境变量classpath指定路径下的类库或系统属性java.class.path指定路径下的类库，正常情况下，应用程序中如果没有自定义类加载器，一般都是用的应用程序类加载器

**自定义类加载器**：除了以上三种类加载器，开发者还可以通过继承ClassLoader来自定义类加载器，定制类的加载方式

java虚拟机对Class文件采用的是按需加载的方式，也就是说只有需要使用到该类时，才会将他的class文件记载到内存，当触发类加载时，jvm并不知道由哪个类加载器去加载，都是默认先给应用程序类加载器，具体怎么分配，java默认使用的是**双亲委派模型**的类加载机制



##### 双亲委派模型

**双亲委派模型**的工作过程是：如果一个类加载器接到了类加载的请求，他首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，每一层的加载器都是如此，所有的加载请求最终都会被传送到最顶层的启动类加载器中，只有父类加载器反馈自己无法完成这个加载请求时，子类加载器才会自己去尝试自己去完成加载。这样做的好处就是java类会随着他的类加载器具备了带有优先级的层级关系，例如Object类，每次加载时都会委派到最顶层的启动类加载器去加载，否则的话如果用户自己也编写了一个Object类，并放在程序的ClassPath中，那么系统中会出现多个不同的Object类。



#### java运行时数据区

java虚拟机会将所管理的内存分为**程序计数器**，**堆**，**方法区**，**java虚拟机栈**和**本地方法栈**，其中方法区和堆是线程共享的区域，程序计数器，虚拟机栈和本地方法栈为线程私有。

##### 方法区

​	在JDK7之前叫永久代，在JDK8之后，改为了在本地内存中开辟了一块元空间，减少了内存溢出（OutOfMemory）的出现次数。线程共享区域，在虚拟机启动时创建，主要存储类型信息，方法信息，域信息，JIT代码缓存（即时编译后的代码）运行时常量池等，当方法区无法满足内存分配需求就会抛出OutOfMemory的错误。



##### 堆

​	jvm所管理内存中最大的一块空间，线程共享区域，也是在虚拟机启动时创建，大小可以通过调整参数实现扩展。几乎所有的实例化都会在这里分配内存，是垃圾收集器管理的内存区域，在物理上可以不是连续的，在逻辑上是连续的，java堆中如果没有足够的内存满足分配需求，并且也无法扩展，就会抛出内存溢出（OutOfMemory）错误，包括**新生代**，**老年代**，**静态变量**和**字符串常量池**，分代有利于提高内存回收的效率

新生代又可以继续分为Eden区（伊甸园区）和Form Survivor和To Survivor区，默认比例为8:1:1。新生代采用的是Minor gc机制，对象优先在Eden区分配空间，大对象直接进入老年代，一次Minor gc首先将Eden区和From Survivor的存活下来的对象复制到To Survivor区，然后使对象的年龄+1，年龄达到阈值（默认15）后移到老年代，然后清空Eden区和From Survivor区，最后将To Survivor中的对象移到From Survivor区。

老年代比较稳定，采用Major gc机制，并且只有在触发了Minor gc，新生代对象进入老年代导致内存不够时触发。Major gc采用标记清除法，先扫描一遍所有的对象，标记出存活的对象，然后回收没有标记的对象。



##### java虚拟机栈

​	每个线程在创建时都会创建一个虚拟机栈，内部保存的是一个个栈帧。方法的一次调用到执行的过程，对应着一个栈帧从入栈到出栈的过程，线程私有。

每个栈帧都存储了方法的局部变量表，操作数栈，动态链接和返回地址等信息，局部变量表用于存放方法参数和方法内部定义的局部变量，操作数栈对应方法的执行，并且存放当前正在操作的变量，动态链接保存的是指向该栈帧所属方法在运行时常量池地址的指针，返回地址存放的是方法在程序计数器中的值，也就是该方法的指令地址。



##### 程序计数器

​	保存的是一个指针，指向的是下一句需要执行的指令，每个线程都有一个独立的程序计数器，在任意一个时刻，一个cpu内核只会执行一条线程中的指令，切换线程后就是通过程序计数器来判断需要执行的指令。是唯一一个不会出现内存溢出错误的区域。



##### 本地方法栈

​	与虚拟机栈类似，只不过虚拟机栈为java方法服务，而本地方法栈为本地方法服务。



补充：

①class常量池、字符串常量池与运行时常量池：class常量池指class文件中的常量池，用于存放编译期生成的各种字面量和符号引用，而运行时常量池除了class常量池中的数据还保存有运行期间新的变量和翻译出来的直接引用。而字符串常量池只保存有字面量的信息。

②string s ="aa" 与new String(“aa”)的区别：String s 为符号引用，直接引用字符串常量池的字面量，而new String实例化了String类，会在堆中也创造一个aa。



#### 执行引擎

执行引擎包括**解释器**、**JIT（即时）编译器**和**垃圾回收器**

##### 解释器

​	jvm运行程序时逐行对字节码进行翻译为本地机器指令。效率低下。



##### JIT编译器

​	对某段代码一次性整体编译为与本地机器平台相关的机器语言，并存入方法区中的JIT代码缓存中，jvm执行时会直接从缓存中获取。提高了执行效率。

最初的java只提供了解释器，但是执行效率低，后来加入了编译器，会将调用频率高的热点代码编译成本地机器码



##### 垃圾回收器

垃圾就是指内存中不再使用的对象，意味着没有指针指向的对象，垃圾回收需要先判断内存中不再使用的对象（GC判断策略）然后再释放这些对象所占用的内存（GC收集算法）

GC判断策略一般有两种——**引用计数法**和**可达性分析法**

**引用计数法**是指给对象添加一个计数器，每有一个地方引用该对象，计数器+1，当计数器为0时，表明该对象不再被引用，这个方法实现简单，效率高但无法检测出循环引用。

**可达性分析法**是目前主流的虚拟机采用的算法，指从所有的GC Root节点出发，寻找该节点所引用的节点，然后继续寻找已找到的节点所引用的节点，直到将所有的节点寻找完毕，剩下的节点被认为是没有引用到的节点，判断为可回收对象，但不会马上回收，会执行一次finalize()方法，可以让开发者对该对象进行自定义操作，下一次依旧判断为可回收对象是才会被回收。GC Root包括虚拟机栈和本地方法栈所引用的对象，方法区中类静态属性和常量所应用的对象等等

垃圾回收算法有**标记清除法**，**标记整理法**，**复制算法**，**分代收集算法**

**标记清除法**就是通过遍历GC Roots将所有可达的对象标记，然后将没有标记的对象回收，缺点是效率低而且会产生内存空间碎片。

**标记整理法**与**标记清除法**类似，但是不会对未标记的对象直接回收，而是将标记的对象向一端移动，然后直接清理掉端边线以外的对象，缺点是效率低

**复制算法是**指将内存分为两个大小相等的部分，每次只使用其中的一块，当其中一块使用完后，将存活的对象复制到另一块，然后一次性清理这一块内存，优点是优化了标记清除法中效率低和内存碎片化严重的问题，但缺点是浪费了一半的内存，而且如果对象存活率高，消耗的时间也不可忽视。

**分代收集算法**是指将内存进行分块，不同的块采用不同的策略，新生代主要采用复制算法，老年代以标记清除法和标记整理法为主。



#### jvm有哪些垃圾收集器

Serial与Seria lOld收集器，最早最基本的收集器，Serial执行单线程的复制算法，在进行垃圾回收时会暂停其他用户线程，Serial Old执行单线程的标记整理法。

ParallelNew，Serial收集器的多线程版本，垃圾回收时同样需要暂停工作线程。采用多线程复制算法。

ParallelScavenge，运用于新生代的多线程复制算法，目的是达到一个可控的吞吐量（吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间））

ParallelOld，ParallelScavenge的老年代版本，采用多线程的标记整理算法。

**CMS垃圾收集器**：使用与老年代，采用多线程的标记清除法，分为四个阶段

①初始标记：仅标记GC Root能直接关联到的对象，需暂停工作线程

②并发标记：进行GC Root跟踪的过程，可与工作现场并发执行

③重新标记：修正并发标记阶段因用户线程继续运行而导致标记发生变动的那一部分对象的标记，需暂停工作现场

④并发清除：清楚GC Roots的不可达对象，可与用户线程并发执行

由于耗时最长的并发标记和并发清除阶段都可以与用户线程一起工作，所以总体上看是与用户线程并发执行的，缺点有三个，并发收集会占用cpu资源，无法处理并发清除阶段产生的新垃圾，会产生内存碎片。

**G1垃圾收集器**：对于新生代和老年代都适用，采用标记整理法，可以设置最大停顿时间。

避免了全区域的收集，将堆内存划分为大小固定的几个独立区域，包括逻辑上的新生代和老年代，同时在后台设置一个优先级列表，每次根据设定的最大停顿时间，优先回收垃圾最多的区域，确保收集器实现最高的回收效率。



#### jvm调优


##### 何时进行调优

首先需要明确，最有效的优化手段是代码和架构层面的优化，JVM 调优是最后不得已的手段，大部分应用是不需要进行 JVM 优化的。
其次遇到一下情况，可以考虑进行 JVM 调优
    Heap内存（老年代）持续上涨，达到最大值
    Full GC 次数频繁
    GC 停顿时间过长
    应用出现 OOM 等异常
    系统吞吐量和响应性能下降



##### JVM 调优步骤

- 分析GC日志及dump文件，判断是否需要优化，遇到的瓶颈问题点；
- 确定 JVM 调优量化目标，及调优参数
- 依次调优内存、延迟、吞吐量等指标
- 对比观察调整前后的差异，然后不断分析调整，直到找到最合适的参数



##### JVM 调优参数

-  -Xms 初始堆内存大小
-  -Xmx 堆内存最大值
-  -Xmn 新生代大小，包括 Eden区和两个Survivor区 新生代大小一般设置为堆内存的 1/3 到 1/4。较大的年轻代可以减少 Minor GC 的频率，但如果过大，可能会影响 Full GC 的效率。
-  -XX：SurvivorRatio 设置Eden区 与 Survivor区的大小比值
-  -XX：NewRatio 老年代与新生代的比例
-  -XX:MetaspaceSize 元空间初始大小
-  -XX:MaxMetaspaceSize 元空间最大大小
-  -XX：MaxDirectMemorySize 直接内存大小 报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。
-  -Xss 线程堆栈大小
-  -XX:MaxGCPauseMillis：设置最大 GC 停顿时间，G1 会根据此目标自动调整堆的布局和垃圾回收频率。



##### 监控工具

可以通过 GCViewer GC日志分析工具分析堆内存使用情况。GC停顿时间等
还可以通过 jmap MAT等工具等分析内存泄漏的原因



#### java的四种引用类型

- 强引用：只要存在就不会被回收，内存不够直接抛出内存溢出错误
- 软引用：只有内存不足是，才会对其回收
- 弱引用：只要垃圾回收机制运行，直接回收
- 虚引用：主要用于在对象被回收时，收到通知



### 5、Spring

spring是一个开源的轻量级的框架，他提供了一个可扩展的开发模型，内部支持对多种开源框架的集成，使得开发者可以专注于业务逻辑的实现，不用过多的关注底层的技术细节，其核心是IOC控制反转和AOP面向切面。



####  IOC

IOC指控制反转，是一种软件设计思想，指把对象的创建和依赖关系的管理权交给IOC容器，从而实现对象之间的解耦合和松耦合，IOC思想基于IOC容器完成，Spring中提供了两种不同的IOC容器

①BeanFactory，是Spring框架的基础设施，面向Spring本身，不提供给开发人员使用

②ApplicationContext，面向的是Spring框架的开发者，是BeanFactory的扩展，提供了更多了功能和特性，大部分应用场景都可以直接使用

IOC中具体的一种实现方式是依赖注入，依赖注入是指将一个对象由依赖的其他对象的引用注入到该对象中,依赖注入的方式有构造函数注入，setter方法注入，接口注入等等。

**优点**：

- 使用者不需要关心 bean 的实现细节。
- 不需要创建多个相同的 bean 导致浪费
- bean 的修改使用方无感知



####  AOP

aop指面向切面，是一种编程范式，在传统的面向对象编程中，通常将系统功能划分为多个模块或类，每个模块负责特定的功能，但是有些功能横跨多个模块（比如：日志，事务管理，权限认证等），这些被称为横切关注点，与核心业务逻辑存在耦合，AOP就是将横切关注点从核心业务逻辑中分离出来，并将其封装成切面，实现对业务逻辑的解耦和重用。

在 Spring 中一般使用环绕通知 @Around 配和 @Pointcut 使用。Spring 中的事务其本质就是通过 AOP 来实现的，对方法前后进行拦截，在执行方法之前开启事务，目标方法执行完后根据情况进行提交后者回滚。

其中AOP对目标对象有两种代理方式

- JDK动态代理，使用的代理对象必须实现了一个接口。核心是通过 InvocationHandler 和 Proxy 类来实现的，可以通过重写InvocationHandler 中的 invoke 方法来实现具体的代理逻辑。

- Cglib代理，如果目标没有实现接口，Spring 会选择使用 Cglib 来代理，cglib 是通过继承的方式实现的动态代理，如果某个类被标记为 final，她是无法被代理的。cglib 是通过 MethodInterceptor 接口实现，可以通过实现 intercept 方法来处理具体的代理逻辑




#### Bean

bean 是指spring中由容器管理的对象实例



##### bean 的生命周期

1.通过构造函数实例化对象

2.依赖注入设置对象属性

3.处理Aware接口   如果bean实现了BeanNameAware、BeanFactoryAware、ApplicationContextAware等接口，会回调相应的方法

4.Bean后置处理器的前置操作，BeanPostProcessor的postProcessInitialization方法，在初始化之前进行一些额外的自定义操作

5.调用bean的初始化方法

6.bean后置处理器的后置操作，BeanPostProcessor的postProcessAfterInitialization，在初始化之后进行，可以在这里进行一些代理增强。

7.使用

8.销毁



##### bean 的作用域

singleton ：单例模式，ioc容器中只会存在一个bean，每次获取时返回同一个实例，多线程下不安全，默认方式

prototype：原型模式，每次容器获取bean时都会创建一个新的实例

request：一次请求一个实例

session：一次session中只会有一个实例

global Session：一个用户在整个应用程序中的会话，只会有一个实例



##### bean 的自动装配

@Autowired，用于自动将相匹配的bean注入到需要依赖的地方，可以简化依赖注入的配置和管理。有如下几种装配方式

ByType，通过参数类型自动装配

ByName，通过参数名自动装配

构造函数，通过构造函数的参数类型自动装配

autoDetect，首先通过构造函数使用autowire装配，失败则通过byType装配



##### bean 的循环依赖

循环依赖是指，两个或以上的 bean 相互注入，最终形成闭环，比如 A 依赖 B，B 依赖 A。

循环依赖在 Spring 中是允许存在的，依据三级缓存解决了大部分的循环依赖。

一级缓存：单例池，缓存那些已经经历了完整生命周期的 bean 对象

二级缓存：缓存早期的 bean 对象，那些生命周期没有走完的

三级缓存：缓存的是 ObjectFactory 对象工厂，用于创建对象

当 A 和 B 循环依赖时流程如下：

实例化 A → A生成一个 ObjectFactory → 由于 A 依赖 B ，此时 B 不存在，所以实例化 B → 创建一个 B 的 ObjectFactory → 由于 B 需要注入 A，所以通过 A 的 ObjectFactory 创建一个 早期的 bean 对象存在二级缓存中 → A 注入给 B，B 创建成功，存入一级缓存 → 将 创建好的B 注入给 A → A 创建成功。

三级缓存模式并不能解决所有的循环依赖，如果在构造函数阶段进行循环依赖则无法避免，可以使用 @Lazy 进行懒加载，需要对象的时候在进行 bean 对象的创建。



#### Spring其他问题

##### **Spring中的单例 bean 是线程安全的嘛**？

在 Spring 中 bean 默认就是单例的，可以通过 @Scope 注解进行修改，默认是 singleton。在 Spring 中注入的 Bean 一般都是无法修改的无状态对象，所以没有线程安全的问题，如果在 bean 中定义了可以修改的成员变量，是需要考虑线程安全问题的，可以加锁或者通过注解为 Prototype 模式。

##### **Spring 中事务失效的情况**

（情况很多，结合项目说几条即可）

- 自己手动处理了异常但是没有抛出。需要抛出异常

- 抛出的异常是检查类异常，如（FilelNotFoundException），可以配置 @Transactional(rollbackFor = Exception.class)

- 非 public 方法会导致事务失效
- 在类内部调用时，应该将自己作为对象注入



#### SpringMVC 流程

SpringMVC指（Model-View-Controller）模型-视图-控制器的架构模式组织和处理web请求

其流程有

1. 将客户端请求提交到前置控制器 DispatcherServlet

2. 由 DispatcherServlet 提交给处理器映射器（HandlerMapping），找到具体的处理器，并生产处理器对象，然后返回给 DispatcherServlet 

3. DispatcherServlet 调用控制器适配器（HandlerAdapter），适配器经过适配后调用具体的处理器

4. 控制器处理完成后返回逻辑视图名称（ModelAndView），由视图解析器（ViewResolver）解析出实际的视图对象。

5. 视图对象接收模型数据，并将数据渲染为最终的响应结果

6. 视图将渲染好的响应结果返回给前置控制器（DispatcherServlet）,再由前置控制器返回给客户端



#### SpringBoot 自动配置原理

SpringBoot 是一个服务于 spring 框架的框架，目的在于简化 Spring 应用程序的开发和部署，提供默认的配置和约定，使开发者专注于业务逻辑的实现，其核心思想是约定大于配置。

SpringBoot 可以自动配置 Spring 应用程序的各种组件和功能，简化依赖管理，内置常见的 Servlet 容器（tomcat等）与 Spring 生态系统紧密集成，可以无缝地使用 Spring 框架的各种功能和模块。

在 Spring Boot 的启动项目中会有 **@SpringBootApplication** 注解，该注解封装了三个注解，有**@SpringBootConfiguration**，**@EnableAutoConfiguration**，**@ComponentScan**。

其中**@EnableAutoConfiguration**是实现自动化配置的核心注解，该注解通过 @import 注解导入对应的配置选择器，内部就是读取了该项目和该项目所引用的 jar 包下的 classpath路径下 META-INF/spring.factories文件中所配置类的全类名，在这些配置类中所定义的Bean会根据诸如 @ConditionalOnClass 之类的条件注解判断是否有对应的 class 文件来决定需要将其导入到 Spring 容器中



### 6、Mybatis

#### Mybatis 的执行流程

1.  加载并解析配置文件（如 mybatis-config.xml）

2.  创建 SqlSessionFactory，全局唯一，用于创建具体的 SqlSession

3.  创建 SqlSession，SqlSession 是应用程序和 Mybatis 之间的接口，不是真正的执行者

4.  SqlSession 通过 Executor 执行器去执行 sql，Executor 是真正的 sql 执行者，还负责管理事务、缓存等

5.  Executor 读取 MappedStatement 信息执行，MappedStatement 封装了具体的 sql 语句，还会将输入与输出信息进行类型转换等

   

#### Mybatis 缓存

Mybatis 分为一级和二级缓存，都是通过 **perpetualCache** 实现的，perpetualCache 本质也是一个 HashMap

一级缓存默认开启，作用域是 SqlSession，所以当 SqlSession 进行 flush 或者 close 之后，缓存就会清空。

二级缓存默认关闭，需要在配置文件和映射文件中开启，不依赖于 SqlSession，当某个作用域进行增删改操作后或者调用方法显示清空的情况下，缓存会被清理。



#### 延迟加载

延迟加载是指需要调用数据时才进行加载，没用到时则不进行加载，可以通过 lazyLoadingEnable = true 开启

延迟加载是通过 CGLIB 代理目标对象来实现的，调用目标方法时，会进入拦截器的 invoke 方法，如何目标为 null，则执行 sql 查询，然后通过 set 方法设置属性值。



### 7、Spring Cloud 

#### **注册中心**  eureka nacos 

##### **注册中心的作用**：

项目采用的是 eureka 作为注册中心，这也是 Spring Cloud 体系中的一个核心组件。主要有三个作用

**服务注册**：服务提供者需要把自己的信息注册到 eureka，由 eureka 来保存这些信息，比如服务名称、IP、端口等

**服务发现**：消费者向 eureka 拉取服务列表信息，如果服务提供者有集群，则消费者会通过负载均衡算法，选择其中一个发起调用

**服务监控**：服务提供者每隔 30s 向 eureka 发送心跳，如果 eureka 超过 90s 没有接收到心跳，则从 eureka 中剔除

##### **nacos 与 eureka 的区别**：

两者都可以提供服务注册和发现，nacos 可以在配置文件中开启非临时实例模式，在临时实例模式下，Nacos 和 eureka 一样采用心跳模式，Nacos 集群默认采用 AP 模式，在非临时实例下，采用主动检测模式，检测到不正常时也不会将其剔除，会将其进行标记，集群中存在非临时实例时采用 CP 模式。

此外相比于 eureka，Nacos 除了提供注册中心的作用外，还是配置中心



#### 负载均衡 Ribbon

微服务的负载均衡主要使用的是一个 Ribbon 组件，比如我们使用 feign 远程调用的时候，底层的负载均衡就是使用了 ribbon

##### Ribbon 的均衡策略

RoundRobinRule：简单轮询策略，简单轮询服务列表选择服务器

WeightedResponseTimeRule：按权重来选择额服务器，响应时间越长，权重越小

RandomRule：随机选择一个可用的服务器

ZoneAvoidanceRule：区域敏感策略，默认策略，使用 Zone 对服务器进行分类，以区域可用的服务器为基础进行服务器的选择，而后对 Zone 内的多个服务器进行轮询

**自定义负载均衡策略如何实现**

1、创建类实现 IRule 接口，可以全局的指定策略。

2、在客户端的配置文件中，可以配置某一个服务的负载均衡策略



#### 服务熔断 Hystrix

在微服务中，一个服务的失败可能会导致整条链路上的服务都失效的情况，这种情况被称为服务雪崩。

一个服务的接口调用失败时，为了确保不收请求突增影响而变得不可用，确保服务崩溃，会使用**服务降级**。服务降级一般与 feign 接口整合，编写降级逻辑。

**服务熔断**：默认是关闭的，需要手动开启，在引导类上添加注解：@EnableCircuitBreaker

如果检测到 10s 内请求失败率超过 50%，就会触发熔断机制，之后每隔 5s 重新尝试请求微服务，如果微服务不能相应，继续走熔断机制，如果可达，则关闭熔断机制，恢复正常请求。



#### 微服务限流方式

**Nginx 限流**  控制速率（漏桶算法）：Nginx 可以存储一定数量的请求，多余的请求会被要求等待或抛弃，然后以恒定的速度每秒放出请求给网关，也可以控制并发数，限制单个 ip 的连接数和并发连接的总数。

**网关限流**：（令牌桶算法）使用 SpringCloud gateway 中支持的局部过滤器 RequestRateLimiter 做限流，每秒以固定的速度生成令牌，直到最大值，只有获得令牌的请求可以被通过。




### 8、Mysql

#### 索引

**索引**：索引是存储系统为了快速查找记录的一种数据结构，需要额外开辟空间和数据维护工作，索引可以加快检索速度，但是同时也会降低增删改的速度。

目前 Mysql 采用的数据结构是 B+ Tree 

B+ Tree 相比于二叉树红黑树，由于拥有更多的子节点，所以树的高度更低，相应的 IO 次数就更少，效率更高

B+ Tree 相比与 B Tree，由于只有叶子节点存储实际的数据，B+ Tree的内部节点可以容纳更多的索引信息，树的高度可能会更低、并且 B+ Tree 的叶子节点之前通过指针相连形成了一个有序链表，使得顺序访问时更加高效。

索引的创建原则：只有数据量较大，超过了10w行数据才会考虑建立索引，并且建立的字段应该是查询比较频繁的字段，一般是查询条件，排序字段，或者分组字段。并且尽量选择组合索引，但是需要严格控制索引的数量。

索引失效的情况：使用组合索引时违反了最左匹配原则，使用 LIKE 的模糊查询 % 在前面会导致索引失效，在索引字段上面进行了运算操作或者类型转换会导致失效，组合索引中使用了范围查询，右侧的索引条件会失效。



#### 事务

事务是一组操作的合集，是不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，要么同事成功要么同时失败。

**事务的特性（ACID）**：

原子性（Atomicity）：事务是不可分割的最小单位，要么全部成功，要么全部失败。

一致性（Consistency）：事务完成时，数据应该和预设结果保持一致。

隔离性（Isolation）：事务的执行不受其他事务的干扰。

持久性（Durability）：事务一旦提交或者回滚，他对数据的改动是永久性的。

**并发事务带来的问题**：

脏读：一个事务读到另外一个事务还没有提交的数据

不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同

幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在

解决方式：给事务设置**隔离级别**：

**READ UNCOMMITTED 未提交读**：三个问题都没有解决

**READ COMMITTED 读已提交**：解决了脏读的问题，没有解决不可重复读和幻读的问题

**REPEATABLE READ 可重复读**：解决了脏读和不可重复读的问题，没有解决幻读的问题，Mysql 默认的级别

**SERIALIZABLE 串行化**：都解决了，但是效率很低，一般不用

**事务的特性是如何保证的？**

Mysql 中存在一个 **redo log** 日志，记录的是数据页的物理变化，服务宕机可以用来同步数据，保证了事务的持久性，有一个 **undo log** 日志，记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，例如当我们 insert 一条数据时，他就会生成一个 delete 的语句，如果回滚就执行此操作，undo log 保证了事务的原子性和一致性。

其中隔离性由锁和 **MVCC** 机制保证，MVCC 翻译过来就是多版本并发控制，就是维护一个数据的多个版本，使得读写操作没有冲突。具体来说就是每张表，还存在一些**隐藏字段**包括 trx_id (事务id，用于记录最近一次修改数据的事务id，自增的)，roll_point（回滚指针，指向上一个版本的事务版本记录），事务修改数据后通过 undo log 记录回滚日志，存储老版本数据，并凭借 roll_point 字段形成一个链表，最后通过 **ReadView** 来决定读取那个版本的数据，ReadView 内部定义了一些匹配规则，不同隔离级别下的快照读也不一样，在RC（读已提交）级别下，每次读取都会生成一个 ReadView，而在RR（可重复读）级别下，只会生成一次 ReadView，后续复用。



#### MVCC

在了解 MVCC 前需要先了解一下**当前读**和**快照读**

**当前读**就是指读取一条记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录加锁，update、insert、delete这些就是当前读

**快照读**就是不加锁的非阻塞读，快照读前提是数据库的隔离级别不是串行化级别，在此级别下快照读会退化成当前读，平时不加锁Select就是快照读

**MVCC**，全称Multi-Version Concurrency Control，即多版本并发控制，指的是维护一个数据的多个版本，是一种解决读写没有冲突无锁并发控制。

MySQL是通过**隐藏字段**、**Undo log** 、 **Read View** 来实现MVCC的。

隐藏字段包括：**DB_ROW_ID** （隐藏的自增主键）、**DB_TRX_ID**（最近修改的事务ID）、**DB_ROLL_PTR**（回滚指针，指向该记录的上一个版本）、**DELETE_BIT**（记录是否被删除，软删除）

以一条 Update 语句为例，在修改时 undo log 会记录被修改前的值，DB_TRX_ID（事务ID）会记录修改该记录的事务ID，DB_ROLL_PTR（回滚指针）会指向该记录在 undo log 中的位置，多次修改通过回滚指针可以使该记录的多个版本形成一个线性表。以实现数据的多个版本。

至于快照读读哪个版本，则根据 **Read View**（读视图）来决定，Read View 就是事务进行快照读的时候生成的一个读视图，会记录系统当前时刻活跃事务的ID（每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大）

**说明**：在RR隔离级别下，只有事务第一次执行快照读的时候生成一个 Read View，后续都使用该 Read View。而在 RC 模式下，每次快照读都会生成一个 Read View。

能否读到某个版本的数据，会进行一系列比较，

​	1、比较该版本的事务ID，与活跃事务中最小的ID，若小于，则说明该事务已提交，可见，若大于，进行下一轮判断

​	2、比较该事务ID 与 系统尚未分配的下一个事务ID，若大于，则说明该版本数据，是在Read View 之后生成的，不可见，小于则继续判断

​	3、判断该事务ID是否在活跃事务列表中，若在，则说明该事务还没有提交，则不可见，若不在则可见。



#### 存储引擎 MyISAM 与 InnoDB

1.存储方式：虽然都是采用的B+树，但InnoDB采用的是聚簇索引，依托主键建立，将索引值与数据全部存储到一个结构中，MyISAM采用的是非聚簇索引或者叫二级索引，是将行的主键值保存在叶子结点中，然后通过主键值查找数据。MyISAM的存储文件有三个.frm(描述表结构的文件)，.MYD（表的数据文件），.MYI（存储的索引文件）。InnoDB只有两个.frm(描述表结构的文件)和.ibd（存储索引和数据）MyISAM的存储文件支持压缩，InnoDB的存储空间要大一点。

2.对事务的支持：MyISAM不支持事务，强调的是性能，查询的速度更快。InnoDB支持事务

3.对锁的支持：MyISAM仅支持表级锁，InnoDB支持行级锁

4.对外键的支持：MyISAM不支持外键，InnoDB支持外键



#### Mysql 中的日志文件及区别

**undo log**：用于记录修改前的数据

**redo log**：用于记录修改后的数据

**bin log**：记录的事整个操作记录

redo log 与 undo log 是  innoDB 存储引擎特有日志文件，主要目的是用于事务管理，记录数据的修改操作以及事务失败后的回滚

bin log 是 Mysql 级别的日志，主要用于主从同步、数据库备份，灾难恢复等



#### SQL优化

**优化流程：**

1. 查看该 SQL，找到可能优化的点，比如使用了 Select * 查询了太多的字段，关联的表过多，在条件列进行计算，模糊查询条件前有百分号等导致索引失效的场景
2. 查看表的数据量，查看是否是表数据量过大引起的，若是过大，需要考虑分库分表

3. 加入 Explain 关键字，查看执行计划，进一步判断相应的优化手段

4. 查看 type 字段，判断是否使用了索引，以及是否是唯一索引。该字段性能情况如下： system > const >  ref > range > index > ALL，尝试建立联合索引优化执行速度

   - ALL：全表扫描
   - index：使用了索引
   - range：使用索引进行了范围查找
   - ref：使用非唯一索引进行了查找
   - const：通过索引一次就找到了结果

5. 查看 rows 字段，该字段表示扫描行数，该值与实际结果的行数越接近越好，使用索引的目的也是使得扫描行数减少。尝试调整SQL或者使用联合索引减少扫描行

6. 查看Extra字段，查看是否使用了临时表或者文件排序，尝试使用联合索引解决。



#### 一条SQL的执行过程

以一条 Update 语句为例

- 通过数据库连接池与 Mysql 建立连接
- 由解析器进行语法分析，生产解析数
- 由优化器生成执行计划，根据索引查看是否可以优化
- Mysql 会先去缓冲池（**BufferPool**）中查找这条数据，如果没有找到，就会去磁盘中查找，若找到就会将这条数据加载到 BufferPool，与此同时，修改之前的原始数据记录到 **undo log** 日志中
- innoDB 在 BufferPool 中进行修改操作，然后将修改之后的数据记录到 **redo log buff** 中
- Mysql 提交事务，此阶段会有一下步骤
  - 将 redo log buff 中的数据写入到 redo 日志文件中，可通过参数配置刷入策略（比如是否立即刷入等）
  - 将本次操作的记录写入到 **bin log** 文件中
  - 将 bin log 文件名称以及更新内容在文件中的位置记录到 redo log 中，同时在 redo log 中添加 commit 标记



#### **分库分表**

包括垂直分库分表和水平分库分表，垂直分库指的是，根据业务类型的不同拆分不同的库。垂直分表说的是根据字段的使用频率，进行分表，将使用频率低的字段单独拆出一个表。水平分库分表说的是将一个库或者表拆分出几个库或者表，保存不同的数据，通过一定的路由规则进行匹配。水平分库分表可以使用 mycat 等中间栈开发。



### 9、mongoDB

#### mongoDB的优势

- 高性能：MongoDB将热点数据存储在内存当中，采用文档数据模型，避免了关系型数据库中复杂的表结构规范化，支持单字段索引、复合索引、全文索引等多种索引。
- 高可用：MongoDB存在数据复制集，可以通过服务器之间的数据复制，避免数据因为单点损坏而丢失。
- 高扩展：MongoDB存在分片（sharding）机制，通过水平扩展将数据集分布在不同的服务器上来提高自己的存储容量和吞吐量。和MySQL分区方案相比，MongoDB的最大区别在于它几乎能自动完成所有事情，只要告诉MongoDB要分配数据，它就能自动维护数据在不同服务器之间的均衡。
- 丰富的查询功能：提供聚合管道、全文搜获、地理空间查询等多种查询方式



#### 支持的数据类型

除了支持 String、Integer、Double、Boolean、Arrays、Datetime 等基础数据类型外，还支持 Object（用于内嵌文档）、Binary Data（二进制数据）、ObjectId（用于创建文档的 ID）、Code（用于在文档中存储 JavaScript代码）等 MongoDB 特有的数据类型



### 10、ElasticSearch




### 11、Redis

redis是一个用C语言开发的高速缓存数据库，其作用是将数据库的热点数据缓存到内存中，避免进行多次的IO磁盘操作，提高系统效率。支持的数据结构有：String，list，set，zset，hash等。

#### Redis持久化

**RDB**：是指将当前内存中的数据集快照写入磁盘

缺点：可能会存在数据丢失的情况、且会占用cpu和内存消耗

**AOF**：是通过保存所有的Redis服务器执行的写命令来记录数据库状态

缺点：由于保存的时命令记录、所以会存在对一个key多次操作的情况，所以文件大小通常比RDB文件大得多。可以让AOF文件执行重写功能、也可以在配置文件中设置达到阈值时自动触发重写

在Redis4.0以后新增了 RDB 和 AOF 的混合持久化



#### 缓存穿透，缓存失效，缓存雪崩

- **缓存穿透**：是指去查询一个不存在的数据，如果存储层中查不到数据通常不会写入缓存层。
  - 解决方式：可以缓存空对象，但将对象的过期时间设置较小或者使用布隆过滤器解决。
- **缓存击穿**：是指当Redis中一个热点在失效的同时大量的请求过来，全部到达数据库，压垮数据库。
  - 解决方式：
    - 设置互斥锁：保证强一致性、但性能较差。
    - 设置逻辑过期：将过期时间存入缓存中、拿到数据时先查看他是否逻辑过期、若过期、则开启互斥锁开启新线程更新缓存中的值、本线程则返回过期数据。其他线程获取互斥锁失败则直接返回过期数据。保证高可用、性能较好。
- **缓存雪崩**：是指Redis中缓存的数据大面积同时失效，或者Redis宕机，从而会导致大量请求直接到数据库，压垮数据库。
  - 解决方式：可以通过设置合理有效期，给不同的KEY的过期时间添加一个（1-5分钟的）随机值、添加多级缓存等方式解决



#### Redis 数据删除策略

**惰性删除**：设置的该 KEY 的时间过期后、先不去管他、当需要该 KEY 的时候、再检测他是否过期，如果过期则删除、反之则返回其值。

优点：对 CPU 的占用较小，对于用不到的 KEY 不会浪费时间检查。

缺点：对内存的占用较大，对于很多用不到的 KEY 会一直存在内存中、不会被释放。

**定期删除**：每隔一段时间，对其中的一部分 KEY 进行检查、删除其中过期的 KEY (直到检查完所有的 KEY ) 定期删除有俩中模式:

SLOW 模式：是定时任务，执行评率默认为10hz，每次不超过25ms，可通过配置文件修改频率。

FAST 模式：执行评率不固定，但每次不低于2ms，每次耗时不超过1ms。

优点：可以通过限制删除操作的执行时长和频率减少对 CPU 的影响、定期删除也可以有效的释放被占用的内存。

缺点：难以确定删除操作执行的时长和频率。

**Redis 是两种策略配和一起使用的**



#### Redis 数据淘汰策略

与删除策略不同的是、删除策略指的是设置的 KEY 过期之后删除的问题、而淘汰策略指的是当 Redis 中的内存不够时、此时再向 Redis 中添加新的 KEY 那么Redis 就会按照某种规则将内存当中的数据删除。

**noeviction**：不淘汰任何 KEY，但内存满时不允许添加新的数据。这是默认的策略

**volatile-ttl**：对设置了 TTL 的 KEY，按照 TTL 的剩余值，TTL较小的优先被淘汰。

**volatile-random**：对于设置了 TTL 的 KEY 随机淘汰。

**volatile-lru**：对设置了 TTL 的 KEY，按照 LRU（最近最少使用）算法进行淘汰。

**volatile-lfu**：对设置了 TTL 的 KEY，按照 LFU （最少频率使用）算法进行淘汰。

**allkeys-random**：对于所有的 KEY 随机淘汰。

**allkeys-lru**：对于全体的 KEY，按照 LRU（最近最少使用）算法进行淘汰。

**allkeys-lfu**：对于全体的 KEY，按照 LFU （最少频率使用）算法进行淘汰。



#### 双写一致性问题

（先说业务背景：允许延迟一致性）

**一致性要求高**：使用 redission 提供的读写锁、

**允许延迟一致**：修改数据库的时候、通过MQ发送通知、删除缓存。



#### Redis实现分布式锁

**使用SETNX指令**：该指令只有在key不存在的时候才能将key的值设置为value，若key已经存在，则SETNX不会做任何动作。在资源使用完成后使用DEL删除该key即可以释放锁。此外还可以通过expire指令设置过期时间。

**使用SET扩展指令**：使用SETNX和expire不是原子操作的，所以如果执行了SETNX指令但是expire指令还没执行性，线程就挂掉了。就会导致死锁。Redis2.6.12之后，Redis扩展了SET命令的参数，只需要使用SET lock 1 EX 10 NX一条命令即可

但是使用SET扩展指令还是会存在两个问题：如果线程还没有执行完成就被自动过期了，锁就会被另一个线程锁获取，第一个线程执行完成后所释放的锁是其他线程的锁。

第一个问题可以使用redission，在线程获取锁时开启一个守护线程自动续期锁的过期时间。第二个问题可以通过新增一个判断条件，判断线程id是自己时才删除锁。

**Redission 实现的锁机制**：

在 Redisson 中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的业务还没有执行完成时，Redission 中引入了一个看门狗的机制，就是每隔一段时间，都会检查当前业务是否还持有锁，如果持有则续期锁的持续时间，当业务执行完成之后需要手动释放锁。

另外当多个线程的竞争锁的时候，获取锁失败时，会尝试自旋一段时间，这样可以第一时间获取锁。

且 Redission 实现的锁是可重入的，锁的信息在 Redis 中进行存储存的事 hash 结构的，数据记录了线程信息和重入的次数，索取锁的时候会判断线程 ID ，如果是当前线程才会开始计数。每次释放锁都会使重入次数减一，减到0的时候才会删除该 KEY。

**使用 redlock**：以上方法都是基于单机模式的Redis实现的，如果出现线程1从主库上获取锁，然后主库异常宕机，SET命令还未同步到从库上。之后从库提升为新的主库，锁在新的主库上丢失了，另一个线程也可以成功获取锁。不过redlock的性能太差，一般不建议使用，如果一定需要保持数据的一致性，可以采用zookeeper实现的分布式锁。

redlock大概原理如下：

使用redlock前，需要至少5个Redis实例，并且这些实例完全相互独立，不存在主从复制。

1.客户端现获取当前时间戳T1

2.客户端依次向这些Redis实例发送加锁请求，并且设置超时时间，如果一个实例获取锁失败就立即向下一个实例申请加锁。

3.如果客户端从大多数实例获取锁成功，并且再次获取当前时间戳T2，只有T2-T1<锁的过期时间才会加锁成功

4.如果获取成功，锁的有效时间等于原有效时间-获取锁的时间。如果获取锁失败，向全部节点发起释放锁请求。



#### Redis 集群模式

redis 提供的集群方案总共有三种：**主从同步**、**哨兵模式**、**Redis 分片集群**

##### 主从同步

单节点的 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，可以搭建主从集群，实现读写分离，一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据后再把数据同步到从节点中。

主要流程：

1.从节点请求同步数据、同时会给主节点发送自己的 replication id 和 offset 偏移量。

2.主节点根据从节点 replication id 与自己的 replication id 是否一致，若一致则说明该从节点不是第一次同步数据，触发增量同步，若不一致则说明该节点是第一次同步数据，选择全量同步。

3.若不一致，选择全量同步，则主节点会发送自己的 replication id 和 offset 偏移量是主从节点的信息保持一致。然后主节点执行 bgsave 生成 rdb 文件发送给从节点文件执行，从节点先清除自己的数据，然后执行此 rdb 文件。如果在 rdb 文件的生成执行期间，依然有请求到了主节点，则会以记录命令的形式保存到缓冲区（也就是一个日志文件）然后发送给从节点，这样就能保证主从节点完全一致。

4.若一致，选择增量同步，则主节点根据从节点的 offset 偏移量，从记录的命令日志中发送从节点 offset 值之后的数据，进是行同步。



##### 哨兵模式

是指主从集群的自动故障恢复，包括检测、自动故障恢复和通知。哨兵会定时监测主从节点是否正常工作，若主节点宕机，则哨兵会选择一个从节点作为主节点，故障回复后也会以新的主节点为主，最后把主节点通知给客户端。

redis 集群的脑裂：这个情况很少见，说的是由于 redis 的主从节点与哨兵节点分别处于不同的网络分区，使得哨兵无法感知到主节点，认为主节点发生了故障，从而将一个从节点提升为主节点。于是同时存在了两个主节点，这样会导致客户端写入数据时还发生在老的主节点，而网络恢复后哨兵会将老主节点降为从节点，会导致数据丢失。

解决方式：可以在 redis 的配置中设置最少的从节点数量以及主从数据复制与同步的延迟时间，达不到要求则拒绝请求。



##### 分片集群

分片集群解决的事海量数据的存储问题，集群中存在多个主节点，每个主节点存储不同的数据，并且可以给每个主节点增加多个从节点以此保证高并发能力，每个主节点之间通过ping监测彼此的运行状态，客户端的请求可以访问集群中的任意节点，最终都会被转发到正确的节点。

​	分片集群引入了 hash 槽的概念，一共有16384个哈希槽，每个主节点绑定一定范围的哈希槽，key 通过 CRC16 校验后对16384取模来决定放入那个槽，通过这个槽找到对应的节点进行存储和取值。





### 12、RabbitMQ

RabbitMQ是基于AMQP协议实现的消息中间件。消息中间件可以用于①异步处理，提升响应速度②流量削峰，解决高并发问题③系统解耦，提升系统可用性。

包括生产者（producer），消费者（consumer），交换机（Exchange），队列（Queue）



#### **工作模式**

- **简单模式**：一个生产者将消息发送到一个队列中，一个消费者从队列中获取并处理消息
- **工作队列模式**：一个生产者将消息发送到一个队列，多个消费者从队列中获取并处理消息，一条消息只能被一个消费者处理，RabbitMQ会尽量平均分发给所有消费者。
- **发布订阅模式**：生产者将消息发送到交换机中，交换机将消息广播到所有绑定的队列，每个队列对应一个消费者
- **路由模式**：生产者将消息发送到交换机中，交换机根据消息所携带的路由键（Routing Key）将消息路由到不同的队列中
- **主题模式**：也被成为通配符模式，与路由模式相似，不同的是，路由模式所指定的 Routing Key 需要与 Binding Key 完全一致，在主题模式下，则是通过通配符匹配



#### 交换机类型

- **直连交换机**（direct Exchange）：通过路由键，将消息发送到与之匹配的队列上

- **主题交换机**（topic Exchange）：可以通过路由键和设置通配符（#（代表零个或多个字符）或*（代表一个字符））进行匹配，将消息发送到一个或多个相匹配的队列上

- **扇形交换机**（Fanout Exchange）：无视路由键，将消息发送到所有与其绑定的队列上

- **延迟交换机**（Delay Exchange）：能延迟发送到队列

- **死信交换机**：可以接受被拒绝的消息，超过最大生存时间的消息，队列达到最大长度后的消息。

  

#### 死信队列

当 RabbitMQ 中的一条正常的消息，因为过了存活时间、队列长度超限、无法路由、被消费者拒绝、消费者处理失败等原因无法被消费时，就会变成死信。当一条消息变成死信时，他就会被发送到死信队列。



#### 延迟消息

1、我们可以通过死信队列来实现，比如给消息设定一个过期时间TTL，但是不去消费他，等他过期就会进入死信队列，然后监听死信队列的消息消费即可。

不过由于RabbitMQ只检查队头的消息是否过期，而不会检查所有的消息，所以当队头消息没有过期，而后面的消息过期了，不会被立即移出，只有等待前面的消息被消费或移出之后才行

2、或者可以通过官方插件实现，在插件方式下，消息会优先保存到一个由 Erlang 开发的 Mnesia 数据库中，然后通过一个定时器去定时查询需要被投递的消息。

这种方式，对版本有要求，需要在3.6.12以上，并且由于消息存在 Mnesia 数据库中，存在丢失可能。



#### RabbitMQ保证消息不被重复消费

1.设置消息全局ID，或者写一个唯一标识，消费者接收到消息后解析出来后就可以判断是否被消费过



#### RabbitMQ保证消息不会丢失

RabbitMQ的消息传递过程一般是：生产者将消息发送给 Exchange，然后由 Exchange 发送到 Queue。

如此一来，消息丢失的情况有三种：

①在生产者传入Exchange的过程中丢失。

②在 Exchange 传入到 Queue 的过程中丢失。

③Queue 接收到消息后，还未被消费就异常宕机。

针对①②：

1.开启RabbitMQ的事务：当RabbitMQ没有接收到消息时回滚事务，只有接收到了才提交事务。事务机制是同步的会降低吞吐量

2.将信道设置为confirm模式，如果RabbitMQ接收到消息会发送一个ack，表示已接收

针对②：

1.消息持久化：将消息持久化需要分别将交换机设置持久化，队列持久化和消息持久化发送（delivery Mode=2）

2.设置镜像集群模式：镜像集群模式下，创建的queue无论是元数据还是消息数据，都存在多个实例，一个实例挂了还可以从另一个实例恢复。（普通集群模式下，其他实例只保存一个queue的元数据不保存消息数据，其他实例可以返回包含消息数据的实例。这个模式只能提高RabbitMQ的吞吐量）



#### RabbitMQ如何保证高可用

RabbitMQ 有两种集群模式

普通集群模式：将 RabbitMQ 实例部署到多个服务器上，多个实例协同工作，共享队列和交换机的元数据，通过内部通信协议，来协调消息的传递和管理。

在这种模式下队列的元数据（配置信息）会在集群中所有实例间进行同步，但队列中的消息只会存在一个实例当中，当消费者消费消息的时候，如果消费者连接到了一个不保存消息的实例是，那么这个实例会根据元数据定位到消息所在实例，拉取消息给消费者消息，生产者同理，如果发送消息到了一个不保存消息的实例，也会被转发。

镜像集群模式：每台服务器都完整的保存着元数据和消息。消息写入时也会在所有实例中都同步一份。



### 13、kafka



### 14、分布式理论

#### CAP 及 BASE 理论

C（Consistency 一致性）、A （Availability 可用性）、P（Partition tolerance 分区容错性），由于微服务之间通过网络连接，所以一定会出现分区问题，出现分区时一致性和可用性就无法同时满足。

BASE 理论是对 CAP 的一种解决思路，包含三个思路：

**B**asically  **A**vailable (基本可用)：分布式系统出现故障时，允许损失部分可用性，保证核心可用。

**S**oft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。

**E**ventually Consistent（最终一致性）：虽然无法强一致性，但是在软状态结束后，最终达到数据一致。

解决分布式事务的思想和模型

最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP 思想）

强一致思想：各分支事务执行完业务先不要提交，等待彼此结果，而后统一提交或者回滚（CP 思想）



#### 分布式事务的解决方案

目前主流的方案主要有阿里的 Seata 框架和 MQ

seata 的 XA 模式：使用的是 CP 理念，等待各个分支事务提交，可以保证强一致性，性能差

seata 的 AT 模式：使用的是 AP 理念，底层通过 undolog 来实现的，性能好

seata 的 TCC 模式：使用的是 AP 理念，性能较好，但需要人工编码

MQ 模式：在 A 服务写数据的时候，需要在同一个事务内发送消息到另一个事务，异步，性能好。AP理念



### 15、DDD 领域驱动设计 及 COLA 架构



#### DDD（领域驱动设计）

领域驱动设计（Domain-Driven Design，DDD）是一种以领域模型为核心的软件设计方法，由Eric Evans于2003年提出。其核心目标是通过领域模型将复杂的业务逻辑显式化，帮助团队在技术实现与业务需求之间建立一致的语言和结构。



#### COLA架构

COLA架构全程：Clean Object-Oriented and Layered Architecture - 整洁面向对象分层架构，是阿里开源的，应用领域驱动设计（DDD）设计思想的架构，cola不仅仅是思想



#### COLA的优势

- 1、组织结构简洁清晰：
  - COLA架构有清晰明确的分层，每一层都有明确的职责
  - 高度模块化，通过上下文的概念，将业务逻辑划分为多个独立的模块，每个模块都有明确的边界和职责，便于管理和维护。
- 2、具有高扩展性和灵活性
- 3、结合 DDD 的思想，以业务逻辑为核心，构建领域层，相比传统的 MVC 三层架构，COLA 更强调领域和上下文划分，且支持更细粒度的业务模块化。



**不足点：**
尽管 COLA 架构已经足够简洁了，但是仍有不完美的地方，比如：每个接口的出入参都会根据业务名定义，导致会出现很多相似DTO，DTO的数量太多。



#### COLA 的分层

- **Adapter（适配层）**：用于处理外部请求的适配和路由，与传统 Controller 层相似。
- **Application（应用层）**：负责获取输入，组装上下文，参数校验，发送消息，调用领域层服务。
- **Domain（领域层）**：核心业务逻辑的实现，是应用的核心，不依赖任何其他层次，通过领域服务和领域对象对应用层提供业务实体和业务逻辑计算
- **Infrastructure（基础设施层）**：负责技术细节的处理。比如数据库的 CRUD，Redis的 GET/SET 等，还包括领域层的防腐，外部依赖需要通过 Gateway 的转义处理，才能被上面的 domain 层使用。




### 16、设计模式

#### 软件设计原则

- **开闭原则**：对扩展开放，对修改关闭。
- **单一职责原则**：一个类只干一件事。
- **里氏替换原则**：在软件中将一个基类对象，替换成他的子类，不会有任何的异常和错误。
- **接口隔离原则**：使用专门的接口，而不是大而全的接口。
- **依赖倒置原则**：面向抽象编程，而不是面向实现编程。
- **迪米特法则**：一个软件实体应当尽可能少地与其他实体发生相互作用
- **组合/聚合复用原则**：尽量使用组合而不是使用继承来达到复用的目的

可以说明的是所有的设计原则都是，前人以“**高内聚，低耦合**”，“**提高复用性和可维护性**”为根本目的，在实践中总结出来的经验，进而演化出来的行为准则。
其中，开闭原则是根本纲领，是面向对象设计的终极目标。



#### 创建型设计模式

**目的：**解决对象创建过程的复杂性和灵活性问题，隐藏对象创建的细节。
**核心思想：**解耦对象的实例化过程，支持灵活的对象创建方式。
**常见模式：**

- ​    **单例模式（Singleton）**：确保一个类只有一个实例。
- ​    **工厂方法（Factory Method）**：将对象创建委托给子类。
- ​    **抽象工厂（Abstract Factory）**：创建相关对象的家族。
- ​    **建造者模式（Builder）**：分步骤构建复杂对象。
- ​    **原型模式（Prototype）**：通过克隆现有对象创建新对象。



#### 结构型设计模式

**目的：**通过组合类或对象形成更大的结构，提升系统的灵活性和可扩展性。
**核心思想：**关注类与对象的组合方式，优化结构关系。
**常见模式：**

- ​    **适配器模式（Adapter）**：转换接口以便不兼容的类协同工作。
- ​    **装饰器模式（Decorator）**：动态为对象添加职责。
- ​    **代理模式（Proxy）**：为其他对象提供代理以控制访问。
- ​    **组合模式（Composite）**：统一处理树形结构中的对象。
- ​    **桥接模式（Bridge）**：分离抽象与实现，使其独立变化。
- ​    **外观模式（Facade）**：提供统一的简化接口。
- ​    **享元模式（Flyweight）**：共享细粒度对象以减少内存开销。



#### 行为型设计模式

**目的：**优化对象间的交互和职责分配，定义对象如何协作完成任务。
**核心思想**：解耦对象间的通信和流程控制。
**常见模式：**

- ​    **策略模式（Strategy）**：封装算法，使其可独立替换。
- ​    **观察者模式（Observer）**：定义对象间的一对多依赖关系。
- ​    **命令模式（Command）**：将请求封装为对象。
- ​    **模板方法（Template Method）**：定义算法的骨架，允许子类重写步骤。
- ​    **责任链模式（Chain of Responsibility）**：动态传递请求处理链。
- ​    **状态模式（State）**：允许对象在内部状态改变时变更行为。
- ​    **访问者模式（Visitor）**：在不修改类的前提下添加新操作。
- ​    **中介者模式（Mediator）**：集中对象间复杂的交互逻辑。



##### 责任链模式

责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。使得多个对象都有机会处理请求，并沿着这条链传递请求，直到有一个对象处理为止

**生活实例：**请假流程。第一步先写好请假条，第二步提交给人事，第三步人事看超过一天交给部门主管，第四步部门主管看超过三天交给老板

**体现的设计模式：****开闭原则**，**单一职责**，**依赖倒置原则**

**优点：**

- ​    降低耦合度：对于请求者，不需要关注处理者是谁，如果处理不了，会转发给下一个处理者。
- ​    可扩展性：增加和删除逻辑，无需要修改原有逻辑，只需要新增或删除一个处理实现即可，完美体现开闭原则。

**缺点：**

- ​    性能问题：如果链过长，可能会影响性能，可能会导致循环调用。
- ​    调试困难：由于不确定是哪个处理器出现的问题，可能需要逐一排查。
- ​    不保证请求一定会被某个处理者处理，可能会出现无法被处理的情况。

**实现：**

- ​    抽象处理者（Handler）：定义一个处理请求的接口，通常包括处理请求的方法，和指向下一个处理者的引用
- ​    具体处理者（ConcreteHandler）：实现抽象处理者接口，负责具体处理请求，如果不能处理则将请求转发给下一个处理者
- ​    客户端（Client）：创建处理对象并组装成责任链，并向第一个ConcreteHandler发起请求。

**补充：**纯粹的责任链模式只能在具体的处理者之间选择一个，也就是说要么自己处理，要么转交给其他处理者。但是在通常情况下，我们可以处理一部分责任。



##### 策略模式

在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。

**生活实例：**商品促销。商品结算时，根据购买的商品金额，选择不同的折扣力度。支付方式。选择支付宝支付还是微信支付

**体现的设计模式：**开闭原则，单一职责，依赖倒置原则

**优点：**
    可扩展性：增加和删除逻辑，无需要修改原有逻辑，只需要新增或删除一个处理实现即可，完美体现开闭原则。
**缺点：**
    客户端需要知道所有的策略类才能调用
    策略类很多的情况下可能会增加系统的复杂度

**实现：**
    抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。
    具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。
    环境（Context）：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。



##### 状态模式

在状态模式（State Pattern）中，类的行为是基于它的状态改变的，状态模式允许对象在内部状态改变时改变其行为，使得对象在不同的状态下有不同的行为表现。通过将每个状态封装成独立的类，可以避免使用大量的条件语句来实现状态切换。

**生活实例：**糖果机：在不同状态下，同样的动作结果不一样。例如，在"投了币"的状态下"转动曲柄"，会售出糖果；而在"没有币"的状态下"转动曲柄"会提示请先投币。

**体现的设计模式：**开闭原则，单一职责，依赖倒置原则

**优点：**
    可扩展性：增加和删除逻辑，无需要修改原有逻辑，只需要新增或删除一个处理实现即可。
**缺点：**
    如果状态数量过多，可能会增加系统复杂度

**实现：**

- ​    抽象状态（State）：定义了一个接口，用于封装与上下文相关的一个状态的行为。
- ​    具体状态（Concrete State）：实现了状态接口，负责处理与该状态相关的行为。具体状态对象通常会在内部维护一个对上下文对象的引用，以便根据不同的条件切换到不同的状态
- ​    上下文（Context）：定义了客户感兴趣的接口，并维护一个当前状态对象的引用。上下文可以通过状态对象来委托处理状态相关的行为。

**补充：**状态模式与策略模式极为相似，从UML图上看是一样的。但两者表达的含义有所不同。
    策略模式的目标是 封装可互换的算法，让客户端主动选择不同的策略，且策略之间无状态关联
    状态模式的目标是 管理对象内部状态的变化，状态有对象内部切换，客户端无感知



##### 观察者模式

观察者模式（Observer Pattern）定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。

**生活实例：**





### 17、线上问题排查



#### CPU 飙高排查

##### 排查方式

1. 使用 top 指令查看 CPU 占用高的进程
2. 使用 top -hp [pid] 查看 CPU占用高的线程
3. 将线程ID转换成十六进制后使用 jstack [PID] 查看具体的堆栈信息

也可以使用 Arthas 等辅助工具。



##### 常见原因

- 死循环或者无限递归
- 频繁GC
- 锁竞争



#### 内存 OOM 排查

##### 排查方式

1. 确定 OOM 类型
   - **Java堆内存溢出**：java.lang.OutOfMemoryError: Java heap space 对象被长期持有
   - **元空间溢出**：java.lang.OutOfMemoryError: Metaspace  类加载过多，动态生产大量类
   - **直接内存溢出**：java.lang.OutOfMemoryError: Direct buffer memory 如NIO的ByteBuffer未正确释放。
   - **线程溢出**：java.lang.OutOfMemoryError: unable to create new native thread 
   - **GC overhead limit exceeded**：GC 效率过低。
2. 获取堆转储文件（Heap Dump）
   1. 如果 JVM 启动参数有配置，则会自动生成
   2. 如果没有也可以手动生成，jmap -dump:format=b,file=dump.hprof [PID]
3. 使用分析工具进行分析，Eclipse MAT、Jprofile 等



##### 常见原因

- 静态集合持有对象引用（如 `static List` 未清理）。
- 缓存未设置过期时间（如 `HashMap` 作为缓存）。
- 资源未关闭（如数据库连接、文件句柄）。
- 线程池或定时器未正确销毁。
